(* this is the prelude for Alt-Ergo, any versions *)
(* this is a prelude for Alt-Ergo integer arithmetic *)
(* this is a prelude for Alt-Ergo real arithmetic *)
logic match_bool : bool, 'a, 'a -> 'a

axiom match_bool_True :
  (forall z:'a. forall z1:'a. (match_bool(true, z, z1) = z))

axiom match_bool_False :
  (forall z:'a. forall z1:'a. (match_bool(false, z, z1) = z1))

type qtmark

type 'a ref = { contents : 'a
}

logic us__ignore : 'a -> unit

type us_private

logic us_null_ext__ : us_private

type us_type_of_heap

type us_image

axiom add_div :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x + y) / z) = ((x / z) + (y / z)))))

axiom sub_div :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x - y) / z) = ((x / z) - (y / z)))))

axiom neg_div :
  (forall x:real. forall y:real. ((not (y = 0.0)) ->
  (((-x) / y) = (-(x / y)))))

axiom assoc_mul_div :
  (forall x:real. forall y:real. forall z:real. ((not (z = 0.0)) ->
  (((x * y) / z) = (x * (y / z)))))

axiom assoc_div_mul :
  (forall x:real. forall y:real. forall z:real. (((not (y = 0.0)) and
  (not (z = 0.0))) -> (((x / y) / z) = (x / (y * z)))))

axiom assoc_div_div :
  (forall x:real. forall y:real. forall z:real. (((not (y = 0.0)) and
  (not (z = 0.0))) -> ((x / (y / z)) = ((x * z) / y))))

function andb(x: bool, y: bool) : bool = match_bool(x, y, false)

function orb(x: bool, y: bool) : bool = match_bool(x, true, y)

function xorb(x: bool, y: bool) : bool = match_bool(y, match_bool(x, false,
  true), match_bool(x, true, false))

function notb(x: bool) : bool = match_bool(x, false, true)

function implb(x: bool, y: bool) : bool = match_bool(y, true, match_bool(x,
  false, true))

function ite(b: bool, x: 'a, y: 'a) : 'a = match_bool(b, x, y)

logic bool_eq : bool, bool -> bool

axiom bool_eq_def :
  (forall x:bool. forall y:bool [bool_eq(x, y)]. (((x = y) -> (bool_eq(x,
  y) = true)) and ((not (x = y)) -> (bool_eq(x, y) = false))))

logic to_int : bool -> int

axiom to_int_def :
  (forall b:bool [to_int(b)]. (((b = true) -> (to_int(b) = 1)) and
  ((not (b = true)) -> (to_int(b) = 0))))

logic of_int : int -> bool

axiom of_int_def :
  (forall i:int [of_int(i)]. (((i = 0) -> (of_int(i) = false)) and
  ((not (i = 0)) -> (of_int(i) = true))))

predicate in_range(x: int) = ((x = 0) or (x = 1))

logic attr__ATTRIBUTE_IMAGE : bool -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check : us_image -> prop

logic attr__ATTRIBUTE_VALUE : us_image -> bool

type 'a map

logic get : 'a map, int -> 'a

logic set : 'a map, int, 'a -> 'a map

axiom Select_eq :
  (forall m:'a map.
  (forall i:int.
  (forall a1:'a [set(m, i, a1)]. (get(set(m, i, a1), i) = a1))))

axiom Select_neq :
  (forall m:'a map.
  (forall i:int. forall j:int.
  (forall a1:'a [get(set(m, i, a1), j)| set(m, i, a1), get(m, j)].
  ((not (i = j)) -> (get(set(m, i, a1), j) = get(m, j))))))

logic bool_eq1 : 'a map, int, int, 'a map, int, int -> bool

axiom T__ada_array___equal_def :
  (forall a:'a1 map.
  (forall af:int.
  (forall al:int.
  (forall b:'a1 map.
  (forall bf:int.
  (forall bl:int [bool_eq1(a, af, al, b, bf, bl)]. ((((((af <= al) and
  (((al - af) + 1) = ((bl - bf) + 1))) or ((not (af <= al)) and
  (bl <  bf))) and
  (forall i:int [get(a, i)]. (((af <= i) and (i <= al)) -> (get(a,
  i) = get(b, ((bf - af) + i)))))) -> (bool_eq1(a, af, al, b, bf,
  bl) = true)) and ((bool_eq1(a, af, al, b, bf, bl) = true) ->
  ((((af <= al) -> (((al - af) + 1) = ((bl - bf) + 1))) and
  ((not (af <= al)) -> (bl <  bf))) and
  (forall i:int [get(a, i)]. (((af <= i) and (i <= al)) -> (get(a,
  i) = get(b, ((bf - af) + i))))))))))))))

logic slide : 'a map, int, int -> 'a map

axiom slide_eq :
  (forall a:'a1 map.
  (forall first:int [slide(a, first, first)]. (slide(a, first, first) = a)))

axiom slide_def :
  (forall a:'a1 map.
  (forall old_first:int.
  (forall new_first:int.
  (forall i:int [get(slide(a, old_first, new_first), i)]. (get(slide(a,
  old_first, new_first), i) = get(a, (i - (new_first - old_first))))))))

logic concat : 'a map, int, int, 'a map, int, int -> 'a map

axiom concat_def :
  (forall a:'a1 map. forall b:'a1 map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(concat(a, a_first, a_last, b, b_first, b_last), i)].
  ((((a_first <= i) and (i <= a_last)) -> (get(concat(a, a_first, a_last, b,
  b_first, b_last), i) = get(a, i))) and ((a_last <  i) -> (get(concat(a,
  a_first, a_last, b, b_first, b_last), i) = get(b,
  ((i - a_last) + (b_first - 1)))))))))

logic compare : 'a map, int, int, 'a map, int, int -> int

logic xorb1 : 'a map, int, int, 'a map, int, int -> 'a map

logic andb1 : 'a map, int, int, 'a map, int, int -> 'a map

logic orb1 : 'a map, int, int, 'a map, int, int -> 'a map

logic notb1 : 'a map, int, int -> 'a map

logic singleton : 'a, int -> 'a map

axiom singleton_def :
  (forall v:'a.
  (forall i:int [get(singleton(v, i), i)]. (get(singleton(v, i), i) = v)))

type userid

predicate in_range1(x: int) = (((-1) <= x) and (x <= 100))

logic bool_eq2 : int, int -> bool

logic bool_ne : int, int -> bool

logic bool_lt : int, int -> bool

logic bool_le : int, int -> bool

logic bool_gt : int, int -> bool

logic bool_ge : int, int -> bool

axiom bool_eq_axiom :
  (forall x:int. (forall y:int. ((bool_eq2(x, y) = true) <-> (x = y))))

axiom bool_ne_axiom :
  (forall x:int. (forall y:int. ((bool_ne(x, y) = true) <-> (not (x = y)))))

axiom bool_lt_axiom :
  (forall x:int. (forall y:int. ((bool_lt(x, y) = true) <-> (x <  y))))

axiom bool_int__le_axiom :
  (forall x:int. (forall y:int. ((bool_le(x, y) = true) <-> (x <= y))))

axiom bool_gt_axiom :
  (forall x:int. (forall y:int. ((bool_gt(x, y) = true) <-> (y <  x))))

axiom bool_ge_axiom :
  (forall x:int. (forall y:int. ((bool_ge(x, y) = true) <-> (y <= x))))

logic bool_eq3 : int, int -> bool

axiom bool_eq_def1 :
  (forall x:int. forall y:int [bool_eq3(x, y)]. (((x = y) -> (bool_eq3(x,
  y) = true)) and ((not (x = y)) -> (bool_eq3(x, y) = false))))

logic attr__ATTRIBUTE_IMAGE1 : int -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check1 : us_image -> prop

logic attr__ATTRIBUTE_VALUE1 : us_image -> int

logic to_rep : userid -> int

logic of_rep : int -> userid

logic user_eq : userid, userid -> bool

logic dummy : userid

axiom inversion_axiom :
  (forall x:userid [to_rep(x)]. (of_rep(to_rep(x)) = x))

axiom range_axiom : (forall x:userid. in_range1(to_rep(x)))

axiom coerce_axiom :
  (forall x:int [to_rep(of_rep(x))]. (in_range1(x) ->
  (to_rep(of_rep(x)) = x)))

type bpm

predicate in_range2(x: int) = (((-1) <= x) and (x <= 300))

logic bool_eq4 : int, int -> bool

axiom bool_eq_def2 :
  (forall x:int. forall y:int [bool_eq4(x, y)]. (((x = y) -> (bool_eq4(x,
  y) = true)) and ((not (x = y)) -> (bool_eq4(x, y) = false))))

logic attr__ATTRIBUTE_IMAGE2 : int -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check2 : us_image -> prop

logic attr__ATTRIBUTE_VALUE2 : us_image -> int

logic to_rep1 : bpm -> int

logic of_rep1 : int -> bpm

logic user_eq1 : bpm, bpm -> bool

logic dummy1 : bpm

axiom inversion_axiom1 :
  (forall x:bpm [to_rep1(x)]. (of_rep1(to_rep1(x)) = x))

axiom range_axiom1 : (forall x:bpm. in_range2(to_rep1(x)))

axiom coerce_axiom1 :
  (forall x:int [to_rep1(of_rep1(x))]. (in_range2(x) ->
  (to_rep1(of_rep1(x)) = x)))

type footsteps

predicate in_range3(x: int) = ((0 <= x) and (x <= 100000))

logic bool_eq5 : int, int -> bool

axiom bool_eq_def3 :
  (forall x:int. forall y:int [bool_eq5(x, y)]. (((x = y) -> (bool_eq5(x,
  y) = true)) and ((not (x = y)) -> (bool_eq5(x, y) = false))))

logic attr__ATTRIBUTE_IMAGE3 : int -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check3 : us_image -> prop

logic attr__ATTRIBUTE_VALUE3 : us_image -> int

logic to_rep2 : footsteps -> int

logic of_rep2 : int -> footsteps

logic user_eq2 : footsteps, footsteps -> bool

logic dummy2 : footsteps

axiom inversion_axiom2 :
  (forall x:footsteps [to_rep2(x)]. (of_rep2(to_rep2(x)) = x))

axiom range_axiom2 : (forall x:footsteps. in_range3(to_rep2(x)))

axiom coerce_axiom2 :
  (forall x:int [to_rep2(of_rep2(x))]. (in_range3(x) ->
  (to_rep2(of_rep2(x)) = x)))

logic abs : real -> real

axiom abs_def :
  (forall x:real [abs(x)]. (((0.0 <= x) -> (abs(x) = x)) and
  ((not (0.0 <= x)) -> (abs(x) = (-x)))))

axiom Abs_le :
  (forall x:real. forall y:real. ((abs(x) <= y) <-> (((-y) <= x) and
  (x <= y))))

axiom Abs_pos : (forall x:real. (0.0 <= abs(x)))

axiom Abs_sum :
  (forall x:real. forall y:real. (abs((x + y)) <= (abs(x) + abs(y))))

axiom Abs_prod :
  (forall x:real. forall y:real. (abs((x * y)) = (abs(x) * abs(y))))

axiom triangular_inequality :
  (forall x:real. forall y:real. forall z:real.
  (abs((x - z)) <= (abs((x - y)) + abs((y - z)))))

logic from_int : int -> real

axiom Zero : (from_int(0) = 0.0)

axiom One : (from_int(1) = 1.0)

axiom Add :
  (forall x:int. forall y:int.
  (from_int((x + y)) = (from_int(x) + from_int(y))))

axiom Sub :
  (forall x:int. forall y:int.
  (from_int((x - y)) = (from_int(x) - from_int(y))))

axiom Mul :
  (forall x:int. forall y:int.
  (from_int((x * y)) = (from_int(x) * from_int(y))))

axiom Neg : (forall x:int. (from_int((-x)) = (-from_int(x))))

axiom Monotonic :
  (forall x:int. forall y:int. ((x <= y) -> (from_int(x) <= from_int(y))))

logic truncate : real -> int

axiom Truncate_int : (forall i:int. (truncate(from_int(i)) = i))

axiom Truncate_down_pos :
  (forall x:real. ((0.0 <= x) -> ((from_int(truncate(x)) <= x) and
  (x <  from_int((truncate(x) + 1))))))

axiom Truncate_up_neg :
  (forall x:real. ((x <= 0.0) -> ((from_int((truncate(x) - 1)) <  x) and
  (x <= from_int(truncate(x))))))

axiom Real_of_truncate :
  (forall x:real. (((x - 1.0) <= from_int(truncate(x))) and
  (from_int(truncate(x)) <= (x + 1.0))))

axiom Truncate_monotonic :
  (forall x:real. forall y:real. ((x <= y) -> (truncate(x) <= truncate(y))))

axiom Truncate_monotonic_int1 :
  (forall x:real. forall i:int. ((x <= from_int(i)) -> (truncate(x) <= i)))

axiom Truncate_monotonic_int2 :
  (forall x:real. forall i:int. ((from_int(i) <= x) -> (i <= truncate(x))))

logic floor : real -> int

logic ceil : real -> int

axiom Floor_int : (forall i:int. (floor(from_int(i)) = i))

axiom Ceil_int : (forall i:int. (ceil(from_int(i)) = i))

axiom Floor_down :
  (forall x:real. ((from_int(floor(x)) <= x) and
  (x <  from_int((floor(x) + 1)))))

axiom Ceil_up :
  (forall x:real. ((from_int((ceil(x) - 1)) <  x) and
  (x <= from_int(ceil(x)))))

axiom Floor_monotonic :
  (forall x:real. forall y:real. ((x <= y) -> (floor(x) <= floor(y))))

axiom Ceil_monotonic :
  (forall x:real. forall y:real. ((x <= y) -> (ceil(x) <= ceil(y))))

logic power : real, int -> real

axiom Power_0 : (forall x:real. (power(x, 0) = 1.0))

axiom Power_s :
  (forall x:real. forall n:int. ((0 <= n) -> (power(x,
  (n + 1)) = (x * power(x, n)))))

axiom Power_s_alt :
  (forall x:real. forall n:int. ((0 <  n) -> (power(x, n) = (x * power(x,
  (n - 1))))))

axiom Power_1 : (forall x:real. (power(x, 1) = x))

axiom Power_sum :
  (forall x:real. forall n:int. forall m:int. ((0 <= n) -> ((0 <= m) ->
  (power(x, (n + m)) = (power(x, n) * power(x, m))))))

axiom Power_mult :
  (forall x:real. forall n:int. forall m:int. ((0 <= n) -> ((0 <= m) ->
  (power(x, (n * m)) = power(power(x, n), m)))))

axiom Power_mult2 :
  (forall x:real. forall y:real. forall n:int. ((0 <= n) -> (power((x * y),
  n) = (power(x, n) * power(y, n)))))

axiom Pow_ge_one :
  (forall x:real. forall n:int. (((0 <= n) and (1.0 <= x)) ->
  (1.0 <= power(x, n))))

logic min : real, real -> real

axiom min_def :
  (forall x:real. forall y:real [min(x, y)]. (((x <= y) -> (min(x,
  y) = x)) and ((not (x <= y)) -> (min(x, y) = y))))

logic max : real, real -> real

axiom max_def :
  (forall x:real. forall y:real [max(x, y)]. (((x <= y) -> (max(x,
  y) = y)) and ((not (x <= y)) -> (max(x, y) = x))))

axiom Min_r : (forall x:real. forall y:real. ((y <= x) -> (min(x, y) = y)))

axiom Max_l : (forall x:real. forall y:real. ((y <= x) -> (max(x, y) = x)))

axiom Min_comm : (forall x:real. forall y:real. (min(x, y) = min(y, x)))

axiom Max_comm : (forall x:real. forall y:real. (max(x, y) = max(y, x)))

axiom Min_assoc :
  (forall x:real. forall y:real. forall z:real. (min(min(x, y), z) = min(x,
  min(y, z))))

axiom Max_assoc :
  (forall x:real. forall y:real. forall z:real. (max(max(x, y), z) = max(x,
  max(y, z))))

type mode = NearestTiesToEven | ToZero | Up | Down | NearestTiesToAway

logic match_mode : mode, 'a, 'a, 'a, 'a, 'a -> 'a

axiom match_mode_NearestTiesToEven :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  (match_mode(NearestTiesToEven, z, z1, z2, z3, z4) = z))

axiom match_mode_ToZero :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  (match_mode(ToZero, z, z1, z2, z3, z4) = z1))

axiom match_mode_Up :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  (match_mode(Up, z, z1, z2, z3, z4) = z2))

axiom match_mode_Down :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  (match_mode(Down, z, z1, z2, z3, z4) = z3))

axiom match_mode_NearestTiesToAway :
  (forall z:'a. forall z1:'a. forall z2:'a. forall z3:'a. forall z4:'a.
  (match_mode(NearestTiesToAway, z, z1, z2, z3, z4) = z4))

type single

logic round : mode, real -> real

logic value : single -> real

logic exact : single -> real

logic model : single -> real

function round_error(x: single) : real = abs((value(x) - exact(x)))

function total_error(x: single) : real = abs((value(x) - model(x)))

predicate no_overflow(m: mode, x: real) = (abs(round(m,
  x)) <= from_int(340282346638528859811704183484516925440))

axiom Bounded_real_no_overflow :
  (forall m:mode. forall x:real.
  ((abs(x) <= from_int(340282346638528859811704183484516925440)) ->
  (abs(round(m, x)) <= from_int(340282346638528859811704183484516925440))))

axiom Round_monotonic :
  (forall m:mode. forall x:real. forall y:real. ((x <= y) -> (round(m,
  x) <= round(m, y))))

axiom Round_idempotent :
  (forall m1:mode. forall m2:mode. forall x:real. (round(m1, round(m2,
  x)) = round(m2, x)))

axiom Round_value :
  (forall m:mode. forall x:single. (round(m, value(x)) = value(x)))

axiom Bounded_value :
  (forall x:single.
  (abs(value(x)) <= from_int(340282346638528859811704183484516925440)))

axiom Exact_rounding_for_integers :
  (forall m:mode. forall i:int. ((((-16777216) <= i) and (i <= 16777216)) ->
  (round(m, from_int(i)) = from_int(i))))

axiom Round_down_le : (forall x:real. (round(Down, x) <= x))

axiom Round_up_ge : (forall x:real. (x <= round(Up, x)))

axiom Round_down_neg : (forall x:real. (round(Down, (-x)) = (-round(Up, x))))

axiom Round_up_neg : (forall x:real. (round(Up, (-x)) = (-round(Down, x))))

logic round_logic : mode, real -> single

axiom Round_logic_def :
  (forall m:mode. forall x:real. ((abs(round(m,
  x)) <= from_int(340282346638528859811704183484516925440)) ->
  (value(round_logic(m, x)) = round(m, x))))

predicate of_real_post(m: mode, x: real, res: single) =
  ((value(res) = round(m, x)) and ((exact(res) = x) and (model(res) = x)))

predicate add_post(m: mode, x: single, y: single, res: single) =
  ((value(res) = round(m, (value(x) + value(y)))) and
  ((exact(res) = (exact(x) + exact(y))) and
  (model(res) = (model(x) + model(y)))))

predicate sub_post(m: mode, x: single, y: single, res: single) =
  ((value(res) = round(m, (value(x) - value(y)))) and
  ((exact(res) = (exact(x) - exact(y))) and
  (model(res) = (model(x) - model(y)))))

predicate mul_post(m: mode, x: single, y: single, res: single) =
  ((value(res) = round(m, (value(x) * value(y)))) and
  ((exact(res) = (exact(x) * exact(y))) and
  (model(res) = (model(x) * model(y)))))

predicate div_post(m: mode, x: single, y: single, res: single) =
  ((value(res) = round(m, (value(x) / value(y)))) and
  ((exact(res) = (exact(x) / exact(y))) and
  (model(res) = (model(x) / model(y)))))

predicate neg_post(x: single, res: single) = ((value(res) = (-value(x))) and
  ((exact(res) = (-exact(x))) and (model(res) = (-model(x)))))

predicate lt(x: single, y: single) = (value(x) <  value(y))

predicate gt(x: single, y: single) = (value(y) <  value(x))

type double

logic round1 : mode, real -> real

logic value1 : double -> real

logic exact1 : double -> real

logic model1 : double -> real

function round_error1(x: double) : real = abs((value1(x) - exact1(x)))

function total_error1(x: double) : real = abs((value1(x) - model1(x)))

predicate no_overflow1(m: mode, x: real) = (abs(round1(m,
  x)) <= from_int(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368))

axiom Bounded_real_no_overflow1 :
  (forall m:mode. forall x:real.
  ((abs(x) <= from_int(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368)) ->
  (abs(round1(m,
  x)) <= from_int(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368))))

axiom Round_monotonic1 :
  (forall m:mode. forall x:real. forall y:real. ((x <= y) -> (round1(m,
  x) <= round1(m, y))))

axiom Round_idempotent1 :
  (forall m1:mode. forall m2:mode. forall x:real. (round1(m1, round1(m2,
  x)) = round1(m2, x)))

axiom Round_value1 :
  (forall m:mode. forall x:double. (round1(m, value1(x)) = value1(x)))

axiom Bounded_value1 :
  (forall x:double.
  (abs(value1(x)) <= from_int(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368)))

axiom Exact_rounding_for_integers1 :
  (forall m:mode. forall i:int. ((((-9007199254740992) <= i) and
  (i <= 9007199254740992)) -> (round1(m, from_int(i)) = from_int(i))))

axiom Round_down_le1 : (forall x:real. (round1(Down, x) <= x))

axiom Round_up_ge1 : (forall x:real. (x <= round1(Up, x)))

axiom Round_down_neg1 :
  (forall x:real. (round1(Down, (-x)) = (-round1(Up, x))))

axiom Round_up_neg1 :
  (forall x:real. (round1(Up, (-x)) = (-round1(Down, x))))

logic round_logic1 : mode, real -> double

axiom Round_logic_def1 :
  (forall m:mode. forall x:real. ((abs(round1(m,
  x)) <= from_int(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368)) ->
  (value1(round_logic1(m, x)) = round1(m, x))))

predicate of_real_post1(m: mode, x: real, res: double) =
  ((value1(res) = round1(m, x)) and ((exact1(res) = x) and
  (model1(res) = x)))

predicate add_post1(m: mode, x: double, y: double, res: double) =
  ((value1(res) = round1(m, (value1(x) + value1(y)))) and
  ((exact1(res) = (exact1(x) + exact1(y))) and
  (model1(res) = (model1(x) + model1(y)))))

predicate sub_post1(m: mode, x: double, y: double, res: double) =
  ((value1(res) = round1(m, (value1(x) - value1(y)))) and
  ((exact1(res) = (exact1(x) - exact1(y))) and
  (model1(res) = (model1(x) - model1(y)))))

predicate mul_post1(m: mode, x: double, y: double, res: double) =
  ((value1(res) = round1(m, (value1(x) * value1(y)))) and
  ((exact1(res) = (exact1(x) * exact1(y))) and
  (model1(res) = (model1(x) * model1(y)))))

predicate div_post1(m: mode, x: double, y: double, res: double) =
  ((value1(res) = round1(m, (value1(x) / value1(y)))) and
  ((exact1(res) = (exact1(x) / exact1(y))) and
  (model1(res) = (model1(x) / model1(y)))))

predicate neg_post1(x: double, res: double) =
  ((value1(res) = (-value1(x))) and ((exact1(res) = (-exact1(x))) and
  (model1(res) = (-model1(x)))))

predicate lt1(x: double, y: double) = (value1(x) <  value1(y))

predicate gt1(x: double, y: double) = (value1(y) <  value1(x))

axiom round_single_bound :
  (forall x:real [round(NearestTiesToEven, x)].
  ((((x - (0x1.0p-24 * abs(x))) - 0x1.0p-150) <= round(NearestTiesToEven,
  x)) and (round(NearestTiesToEven,
  x) <= ((x + (0x1.0p-24 * abs(x))) + 0x1.0p-150))))

axiom round_double_bound :
  (forall x:real [round1(NearestTiesToEven, x)].
  ((((x - (0x1.0p-53 * abs(x))) - 0x1.0p-1075) <= round1(NearestTiesToEven,
  x)) and (round1(NearestTiesToEven,
  x) <= ((x + (0x1.0p-53 * abs(x))) + 0x1.0p-1075))))

axiom round_double_single :
  (forall x:real [round(NearestTiesToEven, x)]. (round1(NearestTiesToEven,
  round(NearestTiesToEven, x)) = round(NearestTiesToEven, x)))

logic bool_lt1 : real, real -> bool

logic bool_le1 : real, real -> bool

logic bool_gt1 : real, real -> bool

logic bool_ge1 : real, real -> bool

logic bool_eq6 : real, real -> bool

logic bool_neq : real, real -> bool

axiom Bool_real__lt_axiom :
  (forall x:real. (forall y:real. ((bool_lt1(x, y) = true) <-> (x <  y))))

axiom Bool_real__le_axiom :
  (forall x:real. (forall y:real. ((bool_le1(x, y) = true) <-> (x <= y))))

axiom Bool_real__gt_axiom :
  (forall x:real. (forall y:real. ((bool_gt1(x, y) = true) <-> (y <  x))))

axiom Bool_real__ge_axiom :
  (forall x:real. (forall y:real. ((bool_ge1(x, y) = true) <-> (y <= x))))

axiom Bool_real__eq_axiom :
  (forall x:real. (forall y:real. ((bool_eq6(x, y) = true) <-> (x = y))))

axiom Bool_real__neq_axiom :
  (forall x:real.
  (forall y:real. ((bool_neq(x, y) = true) <-> (not (x = y)))))

logic round2 : real -> int

axiom Round_down :
  (forall x:real. (((x - from_int(floor(x))) <  0.5) ->
  (round2(x) = floor(x))))

axiom Round_up :
  (forall x:real. (((from_int(ceil(x)) - x) <  0.5) ->
  (round2(x) = ceil(x))))

axiom Round_neg_tie :
  (forall x:real. ((((x - from_int(floor(x))) = 0.5) and (x <  0.0)) ->
  (round2(x) = floor(x))))

axiom Round_pos_tie :
  (forall x:real. ((((from_int(ceil(x)) - x) = 0.5) and (0.0 <  x)) ->
  (round2(x) = ceil(x))))

axiom Round_int :
  (forall i:int [round2(from_int(i))]. (round2(from_int(i)) = i))

axiom Round_near_int :
  (forall i:int.
  (forall x:real. ((((-0.5) <  x) and (x <  0.5)) ->
  (round2((from_int(i) + x)) = i))))

axiom Round_monotonic2 :
  (forall x:real. forall y:real. ((x <= y) -> (round2(x) <= round2(y))))

axiom Round_monotonic_int1 :
  (forall x:real. forall i:int. ((x <= from_int(i)) -> (round2(x) <= i)))

axiom Round_monotonic_int2 :
  (forall x:real. forall i:int. ((from_int(i) <= x) -> (i <= round2(x))))

axiom Round_bound :
  (forall x:real. (((x - 0.5) <= from_int(round2(x))) and
  (from_int(round2(x)) <= (x + 0.5))))

type latitude

predicate in_range4(x: real) = (((-from_int(90)) <= x) and
  (x <= from_int(90)))

logic bool_eq7 : real, real -> bool

axiom bool_eq_def4 :
  (forall x:real. forall y:real [bool_eq7(x, y)]. (((x = y) -> (bool_eq7(x,
  y) = true)) and ((not (x = y)) -> (bool_eq7(x, y) = false))))

logic to_real : latitude -> real

logic of_real : real -> latitude

logic user_eq3 : latitude, latitude -> bool

logic next_representable : real -> real

logic prev_representable : real -> real

axiom next_representable_def :
  (forall x:real [next_representable(x)]. (x <  next_representable(x)))

axiom prev_representable_def :
  (forall x:real [prev_representable(x)]. (prev_representable(x) <  x))

logic attr__ATTRIBUTE_IMAGE4 : real -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check4 : us_image -> prop

logic attr__ATTRIBUTE_VALUE4 : us_image -> real

logic dummy3 : latitude

axiom inversion_axiom3 :
  (forall x:latitude [to_real(x)]. (of_real(to_real(x)) = x))

axiom representable_first : (round(NearestTiesToEven,
  (-from_int(90))) = (-from_int(90)))

axiom representable_last : (round(NearestTiesToEven,
  from_int(90)) = from_int(90))

axiom range_axiom3 : (forall x:latitude. in_range4(to_real(x)))

type longitude

predicate in_range5(x: real) = (((-from_int(180)) <= x) and
  (x <= from_int(180)))

logic to_real1 : longitude -> real

logic of_real1 : real -> longitude

logic user_eq4 : longitude, longitude -> bool

logic next_representable1 : real -> real

logic prev_representable1 : real -> real

axiom next_representable_def1 :
  (forall x:real [next_representable1(x)]. (x <  next_representable1(x)))

axiom prev_representable_def1 :
  (forall x:real [prev_representable1(x)]. (prev_representable1(x) <  x))

logic attr__ATTRIBUTE_IMAGE5 : real -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check5 : us_image -> prop

logic attr__ATTRIBUTE_VALUE5 : us_image -> real

logic dummy4 : longitude

axiom inversion_axiom4 :
  (forall x:longitude [to_real1(x)]. (of_real1(to_real1(x)) = x))

axiom representable_first1 : (round(NearestTiesToEven,
  (-from_int(180))) = (-from_int(180)))

axiom representable_last1 : (round(NearestTiesToEven,
  from_int(180)) = from_int(180))

axiom range_axiom4 : (forall x:longitude. in_range5(to_real1(x)))

type us_split_fields = { rec__lat : latitude; rec__long : longitude
}

type gpslocation = { us_split_fields1 : us_split_fields
}

logic bool_eq8 : gpslocation, gpslocation -> bool

axiom bool_eq_def5 :
  (forall a:gpslocation. forall b:gpslocation [bool_eq8(a, b)].
  ((((to_real(((a).us_split_fields1).rec__lat) = to_real(((b).us_split_fields1).rec__lat)) and
  (to_real1(((a).us_split_fields1).rec__long) = to_real1(((b).us_split_fields1).rec__long))) ->
  (bool_eq8(a, b) = true)) and
  ((not ((to_real(((a).us_split_fields1).rec__lat) = to_real(((b).us_split_fields1).rec__lat)) and
  (to_real1(((a).us_split_fields1).rec__long) = to_real1(((b).us_split_fields1).rec__long)))) ->
  (bool_eq8(a, b) = false))))

logic user_eq5 : gpslocation, gpslocation -> bool

logic value__size : int

logic object__size : gpslocation -> int

axiom value__size_axiom : (0 <= value__size)

axiom object__size_axiom :
  (forall a:latitude. forall a1:longitude. (0 <= object__size({
  us_split_fields1 = { rec__lat = a; rec__long = a1 } })))

logic dummy5 : latitude

logic dummy6 : longitude

logic dummy7 : bool map

logic value__size1 : int

logic object__size1 : bool map -> int

axiom value__size_axiom1 : (0 <= value__size1)

axiom object__size_axiom1 : (forall a:bool map. (0 <= object__size1(a)))

logic user_eq6 : bool map, bool map -> bool

axiom compare_def :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int [compare(a, a_first, a_last, b, b_first, b_last)].
  (((compare(a, a_first, a_last, b, b_first, b_last) = 0) <-> (bool_eq1(a,
  a_first, a_last, b, b_first, b_last) = true)) and (((compare(a, a_first,
  a_last, b, b_first, b_last) <  0) <->
  (exists i:int. exists j:int. ((i <= a_last) and ((j <  b_last) and
  ((bool_eq1(a, a_first, i, b, b_first, j) = true) and ((i = a_last) or
  ((i <  a_last) and (to_int(get(a, (i + 1))) <  to_int(get(b,
  (j + 1))))))))))) and ((0 <  compare(a, a_first, a_last, b, b_first,
  b_last)) <->
  (exists i:int. exists j:int. ((i <= b_last) and ((j <  a_last) and
  ((bool_eq1(a, a_first, j, b, b_first, i) = true) and ((i = b_last) or
  ((i <  b_last) and (to_int(get(b, (i + 1))) <  to_int(get(a,
  (j + 1)))))))))))))))

axiom op_def :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(orb1(a, a_first, a_last, b, b_first, b_last), i)].
  (((a_first <= i) and (i <= a_last)) -> (get(orb1(a, a_first, a_last, b,
  b_first, b_last), i) = match_bool(get(a, i), true, get(b,
  ((i - a_first) + b_first))))))))

axiom op_def1 :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(andb1(a, a_first, a_last, b, b_first, b_last), i)].
  (((a_first <= i) and (i <= a_last)) -> (get(andb1(a, a_first, a_last, b,
  b_first, b_last), i) = match_bool(get(a, i), get(b,
  ((i - a_first) + b_first)), false))))))

axiom op_def2 :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(xorb1(a, a_first, a_last, b, b_first, b_last), i)].
  (((a_first <= i) and (i <= a_last)) -> (get(xorb1(a, a_first, a_last, b,
  b_first, b_last), i) = xorb(get(a, i), get(b,
  ((i - a_first) + b_first))))))))

axiom notb_def :
  (forall a:bool map.
  (forall a_first:int. forall a_last:int.
  (forall i:int [get(notb1(a, a_first, a_last), i)]. (((a_first <= i) and
  (i <= a_last)) -> (get(notb1(a, a_first, a_last), i) = match_bool(get(a,
  i), false, true))))))

logic dummy8 : userid map

logic value__size2 : int

logic object__size2 : userid map -> int

axiom value__size_axiom2 : (0 <= value__size2)

axiom object__size_axiom2 : (forall a:userid map. (0 <= object__size2(a)))

logic user_eq7 : userid map, userid map -> bool

axiom compare_def1 :
  (forall a:userid map. forall b:userid map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int [compare(a, a_first, a_last, b, b_first, b_last)].
  (((compare(a, a_first, a_last, b, b_first, b_last) = 0) <-> (bool_eq1(a,
  a_first, a_last, b, b_first, b_last) = true)) and (((compare(a, a_first,
  a_last, b, b_first, b_last) <  0) <->
  (exists i:int. exists j:int. ((i <= a_last) and ((j <  b_last) and
  ((bool_eq1(a, a_first, i, b, b_first, j) = true) and ((i = a_last) or
  ((i <  a_last) and (to_rep(get(a, (i + 1))) <  to_rep(get(b,
  (j + 1))))))))))) and ((0 <  compare(a, a_first, a_last, b, b_first,
  b_last)) <->
  (exists i:int. exists j:int. ((i <= b_last) and ((j <  a_last) and
  ((bool_eq1(a, a_first, j, b, b_first, i) = true) and ((i = b_last) or
  ((i <  b_last) and (to_rep(get(b, (i + 1))) <  to_rep(get(a,
  (j + 1)))))))))))))))

logic dummy9 : bpm map

logic value__size3 : int

logic object__size3 : bpm map -> int

axiom value__size_axiom3 : (0 <= value__size3)

axiom object__size_axiom3 : (forall a:bpm map. (0 <= object__size3(a)))

logic user_eq8 : bpm map, bpm map -> bool

axiom compare_def2 :
  (forall a:bpm map. forall b:bpm map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int [compare(a, a_first, a_last, b, b_first, b_last)].
  (((compare(a, a_first, a_last, b, b_first, b_last) = 0) <-> (bool_eq1(a,
  a_first, a_last, b, b_first, b_last) = true)) and (((compare(a, a_first,
  a_last, b, b_first, b_last) <  0) <->
  (exists i:int. exists j:int. ((i <= a_last) and ((j <  b_last) and
  ((bool_eq1(a, a_first, i, b, b_first, j) = true) and ((i = a_last) or
  ((i <  a_last) and (to_rep1(get(a, (i + 1))) <  to_rep1(get(b,
  (j + 1))))))))))) and ((0 <  compare(a, a_first, a_last, b, b_first,
  b_last)) <->
  (exists i:int. exists j:int. ((i <= b_last) and ((j <  a_last) and
  ((bool_eq1(a, a_first, j, b, b_first, i) = true) and ((i = b_last) or
  ((i <  b_last) and (to_rep1(get(b, (i + 1))) <  to_rep1(get(a,
  (j + 1)))))))))))))))

logic dummy10 : footsteps map

logic value__size4 : int

logic object__size4 : footsteps map -> int

axiom value__size_axiom4 : (0 <= value__size4)

axiom object__size_axiom4 : (forall a:footsteps map. (0 <= object__size4(a)))

logic user_eq9 : footsteps map, footsteps map -> bool

axiom compare_def3 :
  (forall a:footsteps map. forall b:footsteps map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int [compare(a, a_first, a_last, b, b_first, b_last)].
  (((compare(a, a_first, a_last, b, b_first, b_last) = 0) <-> (bool_eq1(a,
  a_first, a_last, b, b_first, b_last) = true)) and (((compare(a, a_first,
  a_last, b, b_first, b_last) <  0) <->
  (exists i:int. exists j:int. ((i <= a_last) and ((j <  b_last) and
  ((bool_eq1(a, a_first, i, b, b_first, j) = true) and ((i = a_last) or
  ((i <  a_last) and (to_rep2(get(a, (i + 1))) <  to_rep2(get(b,
  (j + 1))))))))))) and ((0 <  compare(a, a_first, a_last, b, b_first,
  b_last)) <->
  (exists i:int. exists j:int. ((i <= b_last) and ((j <  a_last) and
  ((bool_eq1(a, a_first, j, b, b_first, i) = true) and ((i = b_last) or
  ((i <  b_last) and (to_rep2(get(b, (i + 1))) <  to_rep2(get(a,
  (j + 1)))))))))))))))

logic dummy11 : gpslocation map

logic value__size5 : int

logic object__size5 : gpslocation map -> int

axiom value__size_axiom5 : (0 <= value__size5)

axiom object__size_axiom5 :
  (forall a:gpslocation map. (0 <= object__size5(a)))

logic user_eq10 : gpslocation map, gpslocation map -> bool

logic attr__ATTRIBUTE_ADDRESS : int

logic attr__ATTRIBUTE_ADDRESS1 : int

logic attr__ATTRIBUTE_ADDRESS2 : int

logic attr__ATTRIBUTE_ADDRESS3 : int

logic attr__ATTRIBUTE_ADDRESS4 : int

logic attr__ATTRIBUTE_ADDRESS5 : int

type t1b

predicate in_range6(x: int) = (((-1) <= x) and (x <= 100))

logic bool_eq9 : int, int -> bool

axiom bool_eq_def6 :
  (forall x:int. forall y:int [bool_eq9(x, y)]. (((x = y) -> (bool_eq9(x,
  y) = true)) and ((not (x = y)) -> (bool_eq9(x, y) = false))))

logic attr__ATTRIBUTE_IMAGE6 : int -> us_image

logic attr__ATTRIBUTE_VALUE__pre_check6 : us_image -> prop

logic attr__ATTRIBUTE_VALUE6 : us_image -> int

logic to_rep3 : t1b -> int

logic of_rep3 : int -> t1b

logic user_eq11 : t1b, t1b -> bool

logic dummy12 : t1b

axiom inversion_axiom5 :
  (forall x:t1b [to_rep3(x)]. (of_rep3(to_rep3(x)) = x))

axiom range_axiom5 : (forall x:t1b. in_range6(to_rep3(x)))

axiom coerce_axiom3 :
  (forall x:int [to_rep3(of_rep3(x))]. (in_range6(x) ->
  (to_rep3(of_rep3(x)) = x)))

logic dummy13 : bool map

logic value__size6 : int

logic object__size6 : bool map -> int

axiom value__size_axiom6 : (0 <= value__size6)

axiom object__size_axiom6 : (forall a:bool map. (0 <= object__size6(a)))

logic user_eq12 : bool map, bool map -> bool

axiom compare_def4 :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int [compare(a, a_first, a_last, b, b_first, b_last)].
  (((compare(a, a_first, a_last, b, b_first, b_last) = 0) <-> (bool_eq1(a,
  a_first, a_last, b, b_first, b_last) = true)) and (((compare(a, a_first,
  a_last, b, b_first, b_last) <  0) <->
  (exists i:int. exists j:int. ((i <= a_last) and ((j <  b_last) and
  ((bool_eq1(a, a_first, i, b, b_first, j) = true) and ((i = a_last) or
  ((i <  a_last) and (to_int(get(a, (i + 1))) <  to_int(get(b,
  (j + 1))))))))))) and ((0 <  compare(a, a_first, a_last, b, b_first,
  b_last)) <->
  (exists i:int. exists j:int. ((i <= b_last) and ((j <  a_last) and
  ((bool_eq1(a, a_first, j, b, b_first, i) = true) and ((i = b_last) or
  ((i <  b_last) and (to_int(get(b, (i + 1))) <  to_int(get(a,
  (j + 1)))))))))))))))

axiom op_def3 :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(orb1(a, a_first, a_last, b, b_first, b_last), i)].
  (((a_first <= i) and (i <= a_last)) -> (get(orb1(a, a_first, a_last, b,
  b_first, b_last), i) = match_bool(get(a, i), true, get(b,
  ((i - a_first) + b_first))))))))

axiom op_def4 :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(andb1(a, a_first, a_last, b, b_first, b_last), i)].
  (((a_first <= i) and (i <= a_last)) -> (get(andb1(a, a_first, a_last, b,
  b_first, b_last), i) = match_bool(get(a, i), get(b,
  ((i - a_first) + b_first)), false))))))

axiom op_def5 :
  (forall a:bool map. forall b:bool map.
  (forall a_first:int. forall a_last:int. forall b_first:int.
  forall b_last:int.
  (forall i:int [get(xorb1(a, a_first, a_last, b, b_first, b_last), i)].
  (((a_first <= i) and (i <= a_last)) -> (get(xorb1(a, a_first, a_last, b,
  b_first, b_last), i) = xorb(get(a, i), get(b,
  ((i - a_first) + b_first))))))))

axiom notb_def1 :
  (forall a:bool map.
  (forall a_first:int. forall a_last:int.
  (forall i:int [get(notb1(a, a_first, a_last), i)]. (((a_first <= i) and
  (i <= a_last)) -> (get(notb1(a, a_first, a_last), i) = match_bool(get(a,
  i), false, true))))))

logic attr__ATTRIBUTE_ADDRESS6 : int

logic attr__ATTRIBUTE_ADDRESS7 : int

logic attr__ATTRIBUTE_ADDRESS8 : int

logic attr__ATTRIBUTE_ADDRESS9 : int

logic attr__ATTRIBUTE_ADDRESS10 : int

logic temp___standard__accountmanagementsystem_62 : bool -> bool map

axiom def_axiom :
  (forall temp___standard__accountmanagementsystem_64:bool
  [temp___standard__accountmanagementsystem_62(temp___standard__accountmanagementsystem_64)].
  (forall temp___standard__accountmanagementsystem_65:int.
  (get(temp___standard__accountmanagementsystem_62(temp___standard__accountmanagementsystem_64),
  temp___standard__accountmanagementsystem_65) = temp___standard__accountmanagementsystem_64)))

axiom real_const_axiom : (0.0 = from_int(0))

axiom real_const_axiom1 :
  (179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0 = from_int(179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368))

axiom real_const_axiom2 : (180.0 = from_int(180))

axiom real_const_axiom3 :
  (340282346638528859811704183484516925440.0 = from_int(340282346638528859811704183484516925440))

axiom real_const_axiom4 : (90.0 = from_int(90))

 (* File "/Users/raywong/Documents/workspace/Ada/Assignment4/gnatprove/accountmanagementsystem/../accountmanagementsystem.mlw", line 16889, characters 5-8 *)
goal WP_parameter_def :
  (forall insurers:userid map. forall friends:userid map.
  forall vitals:bpm map. forall mfootsteps:footsteps map.
  forall locations:gpslocation map. forall o:bool map. forall o1:userid.
  forall o2:userid map. forall o3:userid. forall o4:userid map.
  forall o5:bpm. forall o6:bpm map. forall o7:footsteps.
  forall o8:footsteps map. forall o9:longitude. forall o10:latitude.
  forall o11:latitude. forall o12:longitude. forall o13:latitude.
  forall o14:longitude. forall o15:gpslocation map.
  forall insurers1:userid map. forall friends1:userid map.
  forall vitals1:bpm map. forall mfootsteps1:footsteps map.
  forall locations1:gpslocation map. forall users:bool map. forall i:int.
  forall friends2:userid map. forall i1:int. forall friends3:userid map.
  forall i2:int. forall friends4:userid map. forall i3:int.
  forall friends5:userid map. forall i4:int. forall i5:int.
  forall insurers2:userid map. forall i6:int. forall insurers3:userid map.
  forall i7:int. forall insurers4:userid map. forall i8:int.
  forall insurers5:userid map. forall i9:int. forall i10:int.
  forall vitals2:bpm map. forall i11:int. forall vitals3:bpm map.
  forall i12:int. forall vitals4:bpm map. forall i13:int.
  forall vitals5:bpm map. forall i14:int. forall i15:int.
  forall mfootsteps2:footsteps map. forall i16:int.
  forall mfootsteps3:footsteps map. forall i17:int.
  forall mfootsteps4:footsteps map. forall i18:int.
  forall mfootsteps5:footsteps map. forall i19:int. forall i20:int.
  forall locations2:gpslocation map. forall i21:int.
  forall locations3:gpslocation map. forall i22:int.
  forall locations4:gpslocation map. forall i23:int.
  forall locations5:gpslocation map. forall i24:int. forall users1:bool map.
  forall insurers6:userid map. forall friends6:userid map.
  forall vitals6:bpm map. forall mfootsteps6:footsteps map.
  forall locations6:gpslocation map. forall i25:int. forall i26:int.
  forall i27:int. forall i28:int. forall i29:int. forall users2:bool map.
  forall insurers7:userid map. forall friends7:userid map.
  forall vitals7:bpm map. forall mfootsteps7:footsteps map.
  forall locations7:gpslocation map. forall i30:int. forall i31:int.
  forall i32:int. forall i33:int. forall i34:int. (((((true and
  (o = temp___standard__accountmanagementsystem_62(of_int(0)))) and
  (users = o)) and (((i = (-1)) and (((((-1) <= i) and (i <= 100)) and
  (((((-1) <= i1) and (i1 <= 100)) and ((((to_rep(o1) = (-1)) and
  (o2 = set(friends2, i1, o1))) and (friends3 = o2)) and ((i2 = (i1 + 1)) and
  (not (i2 <= 100))))) and (((i2 = i3) and (friends3 = friends4)) and
  ((i4 = i2) and (friends5 = friends3))))) or ((not (((-1) <= i) and
  (i <= 100))) and (((i = i3) and (friends = friends4)) and ((i4 = i) and
  (friends5 = friends1)))))) and (((i5 = (-1)) and (((((-1) <= i5) and
  (i5 <= 100)) and (((((-1) <= i6) and (i6 <= 100)) and
  ((((to_rep(o3) = (-1)) and (o4 = set(insurers2, i6, o3))) and
  (insurers3 = o4)) and ((i7 = (i6 + 1)) and (not (i7 <= 100))))) and
  (((i7 = i8) and (insurers3 = insurers4)) and ((i9 = i7) and
  (insurers5 = insurers3))))) or ((not (((-1) <= i5) and (i5 <= 100))) and
  (((i5 = i8) and (insurers = insurers4)) and ((i9 = i5) and
  (insurers5 = insurers1)))))) and (((i10 = (-1)) and (((((-1) <= i10) and
  (i10 <= 100)) and (((((-1) <= i11) and (i11 <= 100)) and
  ((((to_rep1(o5) = (-1)) and (o6 = set(vitals2, i11, o5))) and
  (vitals3 = o6)) and ((i12 = (i11 + 1)) and (not (i12 <= 100))))) and
  (((i12 = i13) and (vitals3 = vitals4)) and ((i14 = i12) and
  (vitals5 = vitals3))))) or ((not (((-1) <= i10) and (i10 <= 100))) and
  (((i10 = i13) and (vitals = vitals4)) and ((i14 = i10) and
  (vitals5 = vitals1)))))) and (((i15 = (-1)) and (((((-1) <= i15) and
  (i15 <= 100)) and (((((-1) <= i16) and (i16 <= 100)) and
  ((((to_rep2(o7) = 0) and (o8 = set(mfootsteps2, i16, o7))) and
  (mfootsteps3 = o8)) and ((i17 = (i16 + 1)) and (not (i17 <= 100))))) and
  (((i17 = i18) and (mfootsteps3 = mfootsteps4)) and ((i19 = i17) and
  (mfootsteps5 = mfootsteps3))))) or ((not (((-1) <= i15) and
  (i15 <= 100))) and (((i15 = i18) and (mfootsteps = mfootsteps4)) and
  ((i19 = i15) and (mfootsteps5 = mfootsteps1)))))) and ((i20 = (-1)) and
  (((((-1) <= i20) and (i20 <= 100)) and (((((-1) <= i21) and
  (i21 <= 100)) and ((((((to_real1(o9) = 0.0e-1) and
  ((to_real(o10) = 0.0e-1) and ((o10 = o11) and (o9 = o12)))) and
  ((o13 = o11) and (o14 = o12))) and (o15 = set(locations2, i21, {
  us_split_fields1 = { rec__lat = o13; rec__long = o14 } }))) and
  (locations3 = o15)) and ((i22 = (i21 + 1)) and (not (i22 <= 100))))) and
  (((i22 = i23) and (locations3 = locations4)) and ((i24 = i22) and
  (locations5 = locations3))))) or ((not (((-1) <= i20) and
  (i20 <= 100))) and (((i20 = i23) and (locations = locations4)) and
  ((i24 = i20) and (locations5 = locations1))))))))))) and (((i29 = i23) and
  ((i28 = i18) and ((i27 = i13) and ((i26 = i8) and ((i25 = i3) and
  ((locations6 = locations4) and ((mfootsteps6 = mfootsteps4) and
  ((vitals6 = vitals4) and ((friends6 = friends4) and
  ((insurers6 = insurers4) and (users1 = users))))))))))) and
  ((i34 = i24) and ((i33 = i19) and ((i32 = i14) and ((i31 = i9) and
  ((i30 = i4) and ((locations7 = locations5) and
  ((mfootsteps7 = mfootsteps5) and ((vitals7 = vitals5) and
  ((friends7 = friends5) and ((insurers7 = insurers5) and
  (users2 = users))))))))))))) ->
  (((((forall i35:int. ((((-1) <= i35) and (i35 <= 100)) ->
      (to_rep(get(friends6, i35)) = (-1)))) and
  (forall i35:int. ((((-1) <= i35) and (i35 <= 100)) ->
  (to_rep(get(insurers6, i35)) = (-1))))) and
  (forall i35:int. ((((-1) <= i35) and (i35 <= 100)) -> (to_rep1(get(vitals6,
  i35)) = (-1))))) and
  (forall i35:int. ((((-1) <= i35) and (i35 <= 100)) ->
  (to_rep2(get(mfootsteps6, i35)) = 0)))) and
  (forall i35:int. ((((-1) <= i35) and (i35 <= 100)) ->
  (bool_eq8(get(locations6, i35), { us_split_fields1 = { rec__lat =
  of_real(0.0e-1); rec__long = of_real1(0.0e-1) } }) = true))))))
