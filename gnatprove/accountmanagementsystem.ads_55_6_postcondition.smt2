(set-logic AUFBVDTNIRA)
;;; generated by SMT-LIB2 driver
;;; SMT-LIB2 driver: bit-vectors, common part
;;; SMT-LIB2: integer arithmetic
;;; SMT-LIB2: real arithmetic
(declare-sort uni 0)

(declare-sort ty 0)

(declare-fun sort (ty uni) Bool)

(declare-fun witness (ty) uni)

;; witness_sort
  (assert (forall ((a ty)) (sort a (witness a))))

(declare-fun int () ty)

(declare-fun real () ty)

(declare-fun bool () ty)

(declare-fun match_bool (ty Bool uni uni) uni)

;; match_bool_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (match_bool a x x1 x2)))))

;; match_bool_True
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni)) (=> (sort a z) (= (match_bool a true z z1) z)))))

;; match_bool_False
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni))
  (=> (sort a z1) (= (match_bool a false z z1) z1)))))

(declare-fun index_bool (Bool) Int)

;; index_bool_True
  (assert (= (index_bool true) 0))

;; index_bool_False
  (assert (= (index_bool false) 1))

(declare-fun tuple0 () ty)

(declare-fun Tuple0 () uni)

;; Tuple0_sort
  (assert (sort tuple0 Tuple0))

(declare-fun qtmark () ty)

(declare-sort ref 1)

(declare-fun ref1 (ty) ty)

(declare-fun mk_ref (ty uni) uni)

;; mk ref_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort (ref1 a) (mk_ref a x)))))

(declare-fun contents (ty uni) uni)

;; contents_sort
  (assert (forall ((a ty)) (forall ((x uni)) (sort a (contents a x)))))

;; contents_def
  (assert
  (forall ((a ty))
  (forall ((u uni)) (=> (sort a u) (= (contents a (mk_ref a u)) u)))))

(declare-fun us__ignore (ty uni) uni)

;; ___ignore_sort
  (assert
  (forall ((a ty)) (forall ((x uni)) (sort tuple0 (us__ignore a x)))))

(declare-fun us_private () ty)

(declare-fun us_null_ext__ () uni)

;; __null_ext___sort
  (assert (sort us_private us_null_ext__))

(declare-fun us_type_of_heap () ty)

(declare-fun us_image () ty)

(declare-sort gpslocation 0)

(declare-fun gpslocation1 () ty)

(declare-sort us_split_fields 0)

(declare-fun us_split_fields1 () ty)

(declare-sort longitude 0)

(declare-fun longitude1 () ty)

(declare-sort latitude 0)

(declare-fun latitude1 () ty)

(declare-sort footsteps 0)

(declare-fun footsteps1 () ty)

(declare-sort bpm 0)

(declare-fun bpm1 () ty)

(declare-sort userid 0)

(declare-fun userid1 () ty)

(declare-sort map1 1)

(declare-fun map2 (ty) ty)

(declare-fun ite1 (ty Bool uni uni) uni)

;; ite_sort
  (assert
  (forall ((a ty))
  (forall ((x Bool) (x1 uni) (x2 uni)) (sort a (ite1 a x x1 x2)))))

(define-fun to_int1 ((b Bool)) Int (ite (= b true) 1 0))

(define-fun of_int ((i Int)) Bool (ite (= i 0) false true))

(define-fun in_range ((x Int)) Bool (or (= x 0) (= x 1)))

(declare-fun attr__ATTRIBUTE_IMAGE (Bool) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Bool)) (sort us_image (attr__ATTRIBUTE_IMAGE x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE (uni) Bool)

(declare-fun get (ty uni Int) uni)

;; get_sort
  (assert
  (forall ((a ty)) (forall ((x uni) (x1 Int)) (sort a (get a x x1)))))

(declare-fun get1 ((map1 userid) Int) userid)

(declare-fun get2 ((map1 bpm) Int) bpm)

(declare-fun get3 ((map1 footsteps) Int) footsteps)

(declare-fun get4 ((map1 gpslocation) Int) gpslocation)

(declare-fun set (ty uni Int uni) uni)

;; set_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 uni)) (sort (map2 a) (set a x x1 x2)))))

(declare-fun t2tb ((map1 gpslocation)) uni)

;; t2tb_sort
  (assert
  (forall ((x (map1 gpslocation))) (sort (map2 gpslocation1) (t2tb x))))

(declare-fun tb2t (uni) (map1 gpslocation))

;; BridgeL
  (assert
  (forall ((i (map1 gpslocation)))
  (! (= (tb2t (t2tb i)) i) :pattern ((t2tb i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map2 gpslocation1) j) (= (t2tb (tb2t j)) j)) :pattern (
  (t2tb (tb2t j))) )))

(declare-fun t2tb1 (gpslocation) uni)

;; t2tb_sort
  (assert (forall ((x gpslocation)) (sort gpslocation1 (t2tb1 x))))

(declare-fun tb2t1 (uni) gpslocation)

;; BridgeL
  (assert
  (forall ((i gpslocation))
  (! (= (tb2t1 (t2tb1 i)) i) :pattern ((t2tb1 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort gpslocation1 j) (= (t2tb1 (tb2t1 j)) j)) :pattern ((t2tb1
                                                                  (tb2t1 j))) )))

;; Select_eq
  (assert
  (forall ((m (map1 gpslocation)))
  (forall ((i Int))
  (forall ((a gpslocation))
  (! (= (get4 (tb2t (set gpslocation1 (t2tb m) i (t2tb1 a))) i) a) :pattern (
  (tb2t (set gpslocation1 (t2tb m) i (t2tb1 a)))) )))))

(declare-fun t2tb2 (footsteps) uni)

;; t2tb_sort
  (assert (forall ((x footsteps)) (sort footsteps1 (t2tb2 x))))

(declare-fun tb2t2 (uni) footsteps)

;; BridgeL
  (assert
  (forall ((i footsteps)) (! (= (tb2t2 (t2tb2 i)) i) :pattern ((t2tb2 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort footsteps1 j) (= (t2tb2 (tb2t2 j)) j)) :pattern ((t2tb2
                                                                (tb2t2 j))) )))

(declare-fun t2tb3 ((map1 footsteps)) uni)

;; t2tb_sort
  (assert (forall ((x (map1 footsteps))) (sort (map2 footsteps1) (t2tb3 x))))

(declare-fun tb2t3 (uni) (map1 footsteps))

;; BridgeL
  (assert
  (forall ((i (map1 footsteps)))
  (! (= (tb2t3 (t2tb3 i)) i) :pattern ((t2tb3 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map2 footsteps1) j) (= (t2tb3 (tb2t3 j)) j)) :pattern (
  (t2tb3 (tb2t3 j))) )))

;; Select_eq
  (assert
  (forall ((m (map1 footsteps)))
  (forall ((i Int))
  (forall ((a footsteps))
  (! (= (get3 (tb2t3 (set footsteps1 (t2tb3 m) i (t2tb2 a))) i) a) :pattern (
  (tb2t3 (set footsteps1 (t2tb3 m) i (t2tb2 a)))) )))))

(declare-fun t2tb4 ((map1 bpm)) uni)

;; t2tb_sort
  (assert (forall ((x (map1 bpm))) (sort (map2 bpm1) (t2tb4 x))))

(declare-fun tb2t4 (uni) (map1 bpm))

;; BridgeL
  (assert
  (forall ((i (map1 bpm))) (! (= (tb2t4 (t2tb4 i)) i) :pattern ((t2tb4 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map2 bpm1) j) (= (t2tb4 (tb2t4 j)) j)) :pattern ((t2tb4
                                                                 (tb2t4 j))) )))

(declare-fun t2tb5 (bpm) uni)

;; t2tb_sort
  (assert (forall ((x bpm)) (sort bpm1 (t2tb5 x))))

(declare-fun tb2t5 (uni) bpm)

;; BridgeL
  (assert
  (forall ((i bpm)) (! (= (tb2t5 (t2tb5 i)) i) :pattern ((t2tb5 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort bpm1 j) (= (t2tb5 (tb2t5 j)) j)) :pattern ((t2tb5 (tb2t5 j))) )))

;; Select_eq
  (assert
  (forall ((m (map1 bpm)))
  (forall ((i Int))
  (forall ((a bpm))
  (! (= (get2 (tb2t4 (set bpm1 (t2tb4 m) i (t2tb5 a))) i) a) :pattern (
  (tb2t4 (set bpm1 (t2tb4 m) i (t2tb5 a)))) )))))

(declare-fun t2tb6 ((map1 userid)) uni)

;; t2tb_sort
  (assert (forall ((x (map1 userid))) (sort (map2 userid1) (t2tb6 x))))

(declare-fun tb2t6 (uni) (map1 userid))

;; BridgeL
  (assert
  (forall ((i (map1 userid)))
  (! (= (tb2t6 (t2tb6 i)) i) :pattern ((t2tb6 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map2 userid1) j) (= (t2tb6 (tb2t6 j)) j)) :pattern ((t2tb6
                                                                    (tb2t6 j))) )))

(declare-fun t2tb7 (userid) uni)

;; t2tb_sort
  (assert (forall ((x userid)) (sort userid1 (t2tb7 x))))

(declare-fun tb2t7 (uni) userid)

;; BridgeL
  (assert
  (forall ((i userid)) (! (= (tb2t7 (t2tb7 i)) i) :pattern ((t2tb7 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort userid1 j) (= (t2tb7 (tb2t7 j)) j)) :pattern ((t2tb7
                                                             (tb2t7 j))) )))

;; Select_eq
  (assert
  (forall ((m (map1 userid)))
  (forall ((i Int))
  (forall ((a userid))
  (! (= (get1 (tb2t6 (set userid1 (t2tb6 m) i (t2tb7 a))) i) a) :pattern (
  (tb2t6 (set userid1 (t2tb6 m) i (t2tb7 a)))) )))))

;; Select_eq
  (assert
  (forall ((a ty))
  (forall ((m uni))
  (forall ((i Int))
  (forall ((a1 uni))
  (! (=> (sort a a1) (= (get a (set a m i a1) i) a1)) :pattern ((set a m i
                                                                a1)) ))))))

;; Select_neq
  (assert
  (forall ((m (map1 gpslocation)))
  (forall ((i Int) (j Int))
  (forall ((a gpslocation))
  (! (=> (not (= i j))
     (= (get4 (tb2t (set gpslocation1 (t2tb m) i (t2tb1 a))) j) (get4 m j))) :pattern (
  (get4 (tb2t (set gpslocation1 (t2tb m) i (t2tb1 a))) j)) :pattern (
  (tb2t (set gpslocation1 (t2tb m) i (t2tb1 a))) (get4 m j)) )))))

;; Select_neq
  (assert
  (forall ((m (map1 footsteps)))
  (forall ((i Int) (j Int))
  (forall ((a footsteps))
  (! (=> (not (= i j))
     (= (get3 (tb2t3 (set footsteps1 (t2tb3 m) i (t2tb2 a))) j) (get3 m j))) :pattern (
  (get3 (tb2t3 (set footsteps1 (t2tb3 m) i (t2tb2 a))) j)) :pattern (
  (tb2t3 (set footsteps1 (t2tb3 m) i (t2tb2 a))) (get3 m j)) )))))

;; Select_neq
  (assert
  (forall ((m (map1 bpm)))
  (forall ((i Int) (j Int))
  (forall ((a bpm))
  (! (=> (not (= i j))
     (= (get2 (tb2t4 (set bpm1 (t2tb4 m) i (t2tb5 a))) j) (get2 m j))) :pattern (
  (get2 (tb2t4 (set bpm1 (t2tb4 m) i (t2tb5 a))) j)) :pattern ((tb2t4
                                                               (set bpm1
                                                               (t2tb4 m) i
                                                               (t2tb5 a)))
  (get2 m j)) )))))

;; Select_neq
  (assert
  (forall ((m (map1 userid)))
  (forall ((i Int) (j Int))
  (forall ((a userid))
  (! (=> (not (= i j))
     (= (get1 (tb2t6 (set userid1 (t2tb6 m) i (t2tb7 a))) j) (get1 m j))) :pattern (
  (get1 (tb2t6 (set userid1 (t2tb6 m) i (t2tb7 a))) j)) :pattern ((tb2t6
                                                                  (set
                                                                  userid1
                                                                  (t2tb6 m) i
                                                                  (t2tb7 a)))
  (get1 m j)) )))))

;; Select_neq
  (assert
  (forall ((a ty))
  (forall ((m uni))
  (forall ((i Int) (j Int))
  (forall ((a1 uni))
  (! (=> (not (= i j)) (= (get a (set a m i a1) j) (get a m j))) :pattern (
  (get a (set a m i a1) j)) :pattern ((set a m i a1) (get a m j)) ))))))

(declare-fun bool_eq (ty uni Int Int uni Int Int) Bool)

;; T__ada_array___equal_def
  (assert
  (forall ((a (map1 gpslocation)))
  (forall ((af Int))
  (forall ((al Int))
  (forall ((b (map1 gpslocation)))
  (forall ((bf Int))
  (forall ((bl Int))
  (! (=
     (and (ite (<= af al) (= (+ (- al af) 1) (+ (- bl bf) 1)) (< bl bf))
     (forall ((i Int))
     (! (=> (and (<= af i) (<= i al))
        (= (get4 a i) (get4 b (+ (- bf af) i)))) :pattern ((get4 a i)) )))
     (= (bool_eq gpslocation1 (t2tb a) af al (t2tb b) bf bl) true)) :pattern (
  (bool_eq gpslocation1 (t2tb a) af al (t2tb b) bf bl)) ))))))))

;; T__ada_array___equal_def
  (assert
  (forall ((a (map1 footsteps)))
  (forall ((af Int))
  (forall ((al Int))
  (forall ((b (map1 footsteps)))
  (forall ((bf Int))
  (forall ((bl Int))
  (! (=
     (and (ite (<= af al) (= (+ (- al af) 1) (+ (- bl bf) 1)) (< bl bf))
     (forall ((i Int))
     (! (=> (and (<= af i) (<= i al))
        (= (get3 a i) (get3 b (+ (- bf af) i)))) :pattern ((get3 a i)) )))
     (= (bool_eq footsteps1 (t2tb3 a) af al (t2tb3 b) bf bl) true)) :pattern (
  (bool_eq footsteps1 (t2tb3 a) af al (t2tb3 b) bf bl)) ))))))))

;; T__ada_array___equal_def
  (assert
  (forall ((a (map1 bpm)))
  (forall ((af Int))
  (forall ((al Int))
  (forall ((b (map1 bpm)))
  (forall ((bf Int))
  (forall ((bl Int))
  (! (=
     (and (ite (<= af al) (= (+ (- al af) 1) (+ (- bl bf) 1)) (< bl bf))
     (forall ((i Int))
     (! (=> (and (<= af i) (<= i al))
        (= (get2 a i) (get2 b (+ (- bf af) i)))) :pattern ((get2 a i)) )))
     (= (bool_eq bpm1 (t2tb4 a) af al (t2tb4 b) bf bl) true)) :pattern (
  (bool_eq bpm1 (t2tb4 a) af al (t2tb4 b) bf bl)) ))))))))

;; T__ada_array___equal_def
  (assert
  (forall ((a (map1 userid)))
  (forall ((af Int))
  (forall ((al Int))
  (forall ((b (map1 userid)))
  (forall ((bf Int))
  (forall ((bl Int))
  (! (=
     (and (ite (<= af al) (= (+ (- al af) 1) (+ (- bl bf) 1)) (< bl bf))
     (forall ((i Int))
     (! (=> (and (<= af i) (<= i al))
        (= (get1 a i) (get1 b (+ (- bf af) i)))) :pattern ((get1 a i)) )))
     (= (bool_eq userid1 (t2tb6 a) af al (t2tb6 b) bf bl) true)) :pattern (
  (bool_eq userid1 (t2tb6 a) af al (t2tb6 b) bf bl)) ))))))))

;; T__ada_array___equal_def
  (assert
  (forall ((a ty))
  (forall ((a1 uni))
  (forall ((af Int))
  (forall ((al Int))
  (forall ((b uni))
  (forall ((bf Int))
  (forall ((bl Int))
  (! (=
     (and (ite (<= af al) (= (+ (- al af) 1) (+ (- bl bf) 1)) (< bl bf))
     (forall ((i Int))
     (! (=> (and (<= af i) (<= i al))
        (= (get a a1 i) (get a b (+ (- bf af) i)))) :pattern ((get a a1 i)) )))
     (= (bool_eq a a1 af al b bf bl) true)) :pattern ((bool_eq a a1 af al b
                                                      bf bl)) )))))))))

(declare-fun slide (ty uni Int Int) uni)

;; slide_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 Int)) (sort (map2 a) (slide a x x1 x2)))))

;; slide_eq
  (assert
  (forall ((a ty))
  (forall ((a1 uni))
  (=> (sort (map2 a) a1)
  (forall ((first Int))
  (! (= (slide a a1 first first) a1) :pattern ((slide a a1 first first)) ))))))

;; slide_def
  (assert
  (forall ((a (map1 gpslocation)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (get4 (tb2t (slide gpslocation1 (t2tb a) old_first new_first)) i) 
  (get4 a (- i (- new_first old_first)))) :pattern ((get4
                                                    (tb2t
                                                    (slide gpslocation1
                                                    (t2tb a) old_first
                                                    new_first)) i)) ))))))

;; slide_def
  (assert
  (forall ((a (map1 footsteps)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (get3 (tb2t3 (slide footsteps1 (t2tb3 a) old_first new_first)) i) 
  (get3 a (- i (- new_first old_first)))) :pattern ((get3
                                                    (tb2t3
                                                    (slide footsteps1
                                                    (t2tb3 a) old_first
                                                    new_first)) i)) ))))))

;; slide_def
  (assert
  (forall ((a (map1 bpm)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (get2 (tb2t4 (slide bpm1 (t2tb4 a) old_first new_first)) i) (get2 a
                                                                    (- i (- new_first old_first)))) :pattern (
  (get2 (tb2t4 (slide bpm1 (t2tb4 a) old_first new_first)) i)) ))))))

;; slide_def
  (assert
  (forall ((a (map1 userid)))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (get1 (tb2t6 (slide userid1 (t2tb6 a) old_first new_first)) i) 
  (get1 a (- i (- new_first old_first)))) :pattern ((get1
                                                    (tb2t6
                                                    (slide userid1 (t2tb6 a)
                                                    old_first new_first)) i)) ))))))

;; slide_def
  (assert
  (forall ((a ty))
  (forall ((a1 uni))
  (forall ((old_first Int))
  (forall ((new_first Int))
  (forall ((i Int))
  (! (= (get a (slide a a1 old_first new_first) i) (get a a1
                                                   (- i (- new_first old_first)))) :pattern (
  (get a (slide a a1 old_first new_first) i)) )))))))

(declare-fun concat1 (ty uni Int Int uni Int Int) uni)

;; concat_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 Int) (x3 uni) (x4 Int) (x5 Int)) (sort
  (map2 a) (concat1 a x x1 x2 x3 x4 x5)))))

;; concat_def
  (assert
  (forall ((a (map1 gpslocation)) (b (map1 gpslocation)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (get4
        (tb2t
        (concat1 gpslocation1 (t2tb a) a_first a_last (t2tb b) b_first
        b_last)) i) (get4 a i)))
     (=> (< a_last i)
     (= (get4
        (tb2t
        (concat1 gpslocation1 (t2tb a) a_first a_last (t2tb b) b_first
        b_last)) i) (get4 b (+ (- i a_last) (- b_first 1)))))) :pattern (
  (get4
  (tb2t
  (concat1 gpslocation1 (t2tb a) a_first a_last (t2tb b) b_first b_last)) i)) )))))

;; concat_def
  (assert
  (forall ((a (map1 footsteps)) (b (map1 footsteps)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (get3
        (tb2t3
        (concat1 footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first
        b_last)) i) (get3 a i)))
     (=> (< a_last i)
     (= (get3
        (tb2t3
        (concat1 footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first
        b_last)) i) (get3 b (+ (- i a_last) (- b_first 1)))))) :pattern (
  (get3
  (tb2t3
  (concat1 footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first b_last)) i)) )))))

;; concat_def
  (assert
  (forall ((a (map1 bpm)) (b (map1 bpm)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (get2
        (tb2t4
        (concat1 bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last)) i) 
     (get2 a i)))
     (=> (< a_last i)
     (= (get2
        (tb2t4
        (concat1 bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last)) i) 
     (get2 b (+ (- i a_last) (- b_first 1)))))) :pattern ((get2
                                                          (tb2t4
                                                          (concat1 bpm1
                                                          (t2tb4 a) a_first
                                                          a_last (t2tb4 b)
                                                          b_first b_last)) i)) )))))

;; concat_def
  (assert
  (forall ((a (map1 userid)) (b (map1 userid)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (get1
        (tb2t6
        (concat1 userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last))
        i) (get1 a i)))
     (=> (< a_last i)
     (= (get1
        (tb2t6
        (concat1 userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last))
        i) (get1 b (+ (- i a_last) (- b_first 1)))))) :pattern ((get1
                                                                (tb2t6
                                                                (concat1
                                                                userid1
                                                                (t2tb6 a)
                                                                a_first
                                                                a_last
                                                                (t2tb6 b)
                                                                b_first
                                                                b_last)) i)) )))))

;; concat_def
  (assert
  (forall ((a ty))
  (forall ((a1 uni) (b uni))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (and
     (=> (and (<= a_first i) (<= i a_last))
     (= (get a (concat1 a a1 a_first a_last b b_first b_last) i) (get a a1 i)))
     (=> (< a_last i)
     (= (get a (concat1 a a1 a_first a_last b b_first b_last) i) (get a b
                                                                 (+ (- i a_last) (- b_first 1)))))) :pattern (
  (get a (concat1 a a1 a_first a_last b b_first b_last) i)) ))))))

(declare-fun compare (ty uni Int Int uni Int Int) Int)

(declare-fun xorb (ty uni Int Int uni Int Int) uni)

;; xorb_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 Int) (x3 uni) (x4 Int) (x5 Int)) (sort
  (map2 a) (xorb a x x1 x2 x3 x4 x5)))))

(declare-fun andb (ty uni Int Int uni Int Int) uni)

;; andb_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 Int) (x3 uni) (x4 Int) (x5 Int)) (sort
  (map2 a) (andb a x x1 x2 x3 x4 x5)))))

(declare-fun orb (ty uni Int Int uni Int Int) uni)

;; orb_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 Int) (x3 uni) (x4 Int) (x5 Int)) (sort
  (map2 a) (orb a x x1 x2 x3 x4 x5)))))

(declare-fun notb (ty uni Int Int) uni)

;; notb_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int) (x2 Int)) (sort (map2 a) (notb a x x1 x2)))))

(declare-fun singleton (ty uni Int) uni)

;; singleton_sort
  (assert
  (forall ((a ty))
  (forall ((x uni) (x1 Int)) (sort (map2 a) (singleton a x x1)))))

;; singleton_def
  (assert
  (forall ((v gpslocation))
  (forall ((i Int))
  (! (= (get4 (tb2t (singleton gpslocation1 (t2tb1 v) i)) i) v) :pattern (
  (get4 (tb2t (singleton gpslocation1 (t2tb1 v) i)) i)) ))))

;; singleton_def
  (assert
  (forall ((v footsteps))
  (forall ((i Int))
  (! (= (get3 (tb2t3 (singleton footsteps1 (t2tb2 v) i)) i) v) :pattern (
  (get3 (tb2t3 (singleton footsteps1 (t2tb2 v) i)) i)) ))))

;; singleton_def
  (assert
  (forall ((v bpm))
  (forall ((i Int))
  (! (= (get2 (tb2t4 (singleton bpm1 (t2tb5 v) i)) i) v) :pattern ((get2
                                                                   (tb2t4
                                                                   (singleton
                                                                   bpm1
                                                                   (t2tb5 v)
                                                                   i)) i)) ))))

;; singleton_def
  (assert
  (forall ((v userid))
  (forall ((i Int))
  (! (= (get1 (tb2t6 (singleton userid1 (t2tb7 v) i)) i) v) :pattern (
  (get1 (tb2t6 (singleton userid1 (t2tb7 v) i)) i)) ))))

;; singleton_def
  (assert
  (forall ((a ty))
  (forall ((v uni))
  (=> (sort a v)
  (forall ((i Int))
  (! (= (get a (singleton a v i) i) v) :pattern ((get a (singleton a v i) i)) ))))))

(define-fun in_range1 ((x Int)) Bool (and (<= (- 1) x) (<= x 100)))

(define-fun bool_eq1 ((x Int) (y Int)) Bool (ite (= x y) true false))

(declare-fun attr__ATTRIBUTE_IMAGE1 (Int) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Int)) (sort us_image (attr__ATTRIBUTE_IMAGE1 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check1 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE1 (uni) Int)

(declare-fun to_rep (userid) Int)

(declare-fun of_rep (Int) userid)

(declare-fun user_eq (userid userid) Bool)

(declare-fun dummy () userid)

;; inversion_axiom
  (assert
  (forall ((x userid)) (! (= (of_rep (to_rep x)) x) :pattern ((to_rep x)) )))

;; range_axiom
  (assert (forall ((x userid)) (in_range1 (to_rep x))))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range1 x) (= (to_rep (of_rep x)) x)) :pattern ((to_rep
                                                            (of_rep x))) )))

(define-fun in_range2 ((x Int)) Bool (and (<= (- 1) x) (<= x 300)))

(define-fun bool_eq2 ((x Int) (y Int)) Bool (ite (= x y) true false))

(declare-fun attr__ATTRIBUTE_IMAGE2 (Int) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Int)) (sort us_image (attr__ATTRIBUTE_IMAGE2 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check2 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE2 (uni) Int)

(declare-fun to_rep1 (bpm) Int)

(declare-fun of_rep1 (Int) bpm)

(declare-fun user_eq1 (bpm bpm) Bool)

(declare-fun dummy1 () bpm)

;; inversion_axiom
  (assert
  (forall ((x bpm)) (! (= (of_rep1 (to_rep1 x)) x) :pattern ((to_rep1 x)) )))

;; range_axiom
  (assert (forall ((x bpm)) (in_range2 (to_rep1 x))))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range2 x) (= (to_rep1 (of_rep1 x)) x)) :pattern ((to_rep1
                                                              (of_rep1 x))) )))

(define-fun in_range3 ((x Int)) Bool (and (<= 0 x) (<= x 100000)))

(define-fun bool_eq3 ((x Int) (y Int)) Bool (ite (= x y) true false))

(declare-fun attr__ATTRIBUTE_IMAGE3 (Int) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Int)) (sort us_image (attr__ATTRIBUTE_IMAGE3 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check3 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE3 (uni) Int)

(declare-fun to_rep2 (footsteps) Int)

(declare-fun of_rep2 (Int) footsteps)

(declare-fun user_eq2 (footsteps footsteps) Bool)

(declare-fun dummy2 () footsteps)

;; inversion_axiom
  (assert
  (forall ((x footsteps))
  (! (= (of_rep2 (to_rep2 x)) x) :pattern ((to_rep2 x)) )))

;; range_axiom
  (assert (forall ((x footsteps)) (in_range3 (to_rep2 x))))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range3 x) (= (to_rep2 (of_rep2 x)) x)) :pattern ((to_rep2
                                                              (of_rep2 x))) )))

(declare-fun power (Real Int) Real)

;; Power_0
  (assert (forall ((x Real)) (= (power x 0) 1.0)))

;; Power_s
  (assert
  (forall ((x Real) (n Int))
  (=> (<= 0 n) (= (power x (+ n 1)) (* x (power x n))))))

;; Power_s_alt
  (assert
  (forall ((x Real) (n Int))
  (=> (< 0 n) (= (power x n) (* x (power x (- n 1)))))))

;; Power_1
  (assert (forall ((x Real)) (= (power x 1) x)))

;; Power_sum
  (assert
  (forall ((x Real) (n Int) (m Int))
  (=> (<= 0 n)
  (=> (<= 0 m) (= (power x (+ n m)) (* (power x n) (power x m)))))))

;; Power_mult
  (assert
  (forall ((x Real) (n Int) (m Int))
  (=> (<= 0 n) (=> (<= 0 m) (= (power x (* n m)) (power (power x n) m))))))

;; Power_mult2
  (assert
  (forall ((x Real) (y Real) (n Int))
  (=> (<= 0 n) (= (power (* x y) n) (* (power x n) (power y n))))))

;; Pow_ge_one
  (assert
  (forall ((x Real) (n Int))
  (=> (and (<= 0 n) (<= 1.0 x)) (<= 1.0 (power x n)))))

(declare-sort mode 0)

(declare-fun mode1 () ty)

(declare-fun NearestTiesToEven () mode)

(declare-fun ToZero () mode)

(declare-fun Up () mode)

(declare-fun Down () mode)

(declare-fun NearestTiesToAway () mode)

(declare-fun match_mode (ty mode uni uni uni uni uni) uni)

;; match_mode_sort
  (assert
  (forall ((a ty))
  (forall ((x mode) (x1 uni) (x2 uni) (x3 uni) (x4 uni) (x5 uni)) (sort a
  (match_mode a x x1 x2 x3 x4 x5)))))

;; match_mode_NearestTiesToEven
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
  (=> (sort a z) (= (match_mode a NearestTiesToEven z z1 z2 z3 z4) z)))))

;; match_mode_ToZero
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
  (=> (sort a z1) (= (match_mode a ToZero z z1 z2 z3 z4) z1)))))

;; match_mode_Up
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
  (=> (sort a z2) (= (match_mode a Up z z1 z2 z3 z4) z2)))))

;; match_mode_Down
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
  (=> (sort a z3) (= (match_mode a Down z z1 z2 z3 z4) z3)))))

;; match_mode_NearestTiesToAway
  (assert
  (forall ((a ty))
  (forall ((z uni) (z1 uni) (z2 uni) (z3 uni) (z4 uni))
  (=> (sort a z4) (= (match_mode a NearestTiesToAway z z1 z2 z3 z4) z4)))))

(declare-fun index_mode (mode) Int)

;; index_mode_NearestTiesToEven
  (assert (= (index_mode NearestTiesToEven) 0))

;; index_mode_ToZero
  (assert (= (index_mode ToZero) 1))

;; index_mode_Up
  (assert (= (index_mode Up) 2))

;; index_mode_Down
  (assert (= (index_mode Down) 3))

;; index_mode_NearestTiesToAway
  (assert (= (index_mode NearestTiesToAway) 4))

(declare-sort single 0)

(declare-fun single1 () ty)

(declare-fun round (mode Real) Real)

(declare-fun value (single) Real)

(declare-fun exact (single) Real)

(declare-fun model (single) Real)

(define-fun round_error ((x single)) Real (ite (>= (- (value x) (exact x)) 0.0) (- 
  (value x) (exact x)) (- (- (value x) (exact x)))))

(define-fun total_error ((x single)) Real (ite (>= (- (value x) (model x)) 0.0) (- 
  (value x) (model x)) (- (- (value x) (model x)))))

(define-fun no_overflow ((m mode)
  (x Real)) Bool (<= (ite (>= (round m x) 0.0) (round m x) (- (round m x))) 340282346638528859811704183484516925440.0))

;; Bounded_real_no_overflow
  (assert
  (forall ((m mode) (x Real))
  (=> (<= (ite (>= x 0.0) x (- x)) 340282346638528859811704183484516925440.0)
  (no_overflow m x))))

;; Round_monotonic
  (assert
  (forall ((m mode) (x Real) (y Real))
  (=> (<= x y) (<= (round m x) (round m y)))))

;; Round_idempotent
  (assert
  (forall ((m1 mode) (m2 mode) (x Real))
  (= (round m1 (round m2 x)) (round m2 x))))

;; Round_value
  (assert (forall ((m mode) (x single)) (= (round m (value x)) (value x))))

;; Bounded_value
  (assert
  (forall ((x single))
  (<= (ite (>= (value x) 0.0) (value x) (- (value x))) 340282346638528859811704183484516925440.0)))

;; Exact_rounding_for_integers
  (assert
  (forall ((m mode) (i Int))
  (=> (and (<= (- 16777216) i) (<= i 16777216))
  (= (round m (to_real i)) (to_real i)))))

;; Round_down_le
  (assert (forall ((x Real)) (<= (round Down x) x)))

;; Round_up_ge
  (assert (forall ((x Real)) (<= x (round Up x))))

;; Round_down_neg
  (assert (forall ((x Real)) (= (round Down (- x)) (- (round Up x)))))

;; Round_up_neg
  (assert (forall ((x Real)) (= (round Up (- x)) (- (round Down x)))))

(declare-fun round_logic (mode Real) single)

;; Round_logic_def
  (assert
  (forall ((m mode) (x Real))
  (=> (no_overflow m x) (= (value (round_logic m x)) (round m x)))))

(define-fun of_real_post ((m mode) (x Real)
  (res single)) Bool (and (= (value res) (round m x))
                     (and (= (exact res) x) (= (model res) x))))

(define-fun add_post ((m mode) (x single) (y single)
  (res single)) Bool (and (= (value res) (round m (+ (value x) (value y))))
                     (and (= (exact res) (+ (exact x) (exact y)))
                     (= (model res) (+ (model x) (model y))))))

(define-fun sub_post ((m mode) (x single) (y single)
  (res single)) Bool (and (= (value res) (round m (- (value x) (value y))))
                     (and (= (exact res) (- (exact x) (exact y)))
                     (= (model res) (- (model x) (model y))))))

(define-fun mul_post ((m mode) (x single) (y single)
  (res single)) Bool (and (= (value res) (round m (* (value x) (value y))))
                     (and (= (exact res) (* (exact x) (exact y)))
                     (= (model res) (* (model x) (model y))))))

(define-fun div_post ((m mode) (x single) (y single)
  (res single)) Bool (and (= (value res) (round m (/ (value x) (value y))))
                     (and (= (exact res) (/ (exact x) (exact y)))
                     (= (model res) (/ (model x) (model y))))))

(define-fun neg_post ((x single)
  (res single)) Bool (and (= (value res) (- (value x)))
                     (and (= (exact res) (- (exact x)))
                     (= (model res) (- (model x))))))

(define-fun lt ((x single) (y single)) Bool (< (value x) (value y)))

(define-fun gt ((x single) (y single)) Bool (< (value y) (value x)))

(declare-sort double 0)

(declare-fun double1 () ty)

(declare-fun round1 (mode Real) Real)

(declare-fun value1 (double) Real)

(declare-fun exact1 (double) Real)

(declare-fun model1 (double) Real)

(define-fun round_error1 ((x double)) Real (ite (>= (- (value1 x) (exact1 x)) 0.0) (- 
  (value1 x) (exact1 x)) (- (- (value1 x) (exact1 x)))))

(define-fun total_error1 ((x double)) Real (ite (>= (- (value1 x) (model1 x)) 0.0) (- 
  (value1 x) (model1 x)) (- (- (value1 x) (model1 x)))))

(define-fun no_overflow1 ((m mode)
  (x Real)) Bool (<= (ite (>= (round1 m x) 0.0) (round1 m x) (- (round1 m x))) 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0))

;; Bounded_real_no_overflow
  (assert
  (forall ((m mode) (x Real))
  (=>
  (<= (ite (>= x 0.0) x (- x)) 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0)
  (no_overflow1 m x))))

;; Round_monotonic
  (assert
  (forall ((m mode) (x Real) (y Real))
  (=> (<= x y) (<= (round1 m x) (round1 m y)))))

;; Round_idempotent
  (assert
  (forall ((m1 mode) (m2 mode) (x Real))
  (= (round1 m1 (round1 m2 x)) (round1 m2 x))))

;; Round_value
  (assert
  (forall ((m mode) (x double)) (= (round1 m (value1 x)) (value1 x))))

;; Bounded_value
  (assert
  (forall ((x double))
  (<= (ite (>= (value1 x) 0.0) (value1 x) (- (value1 x))) 179769313486231570814527423731704356798070567525844996598917476803157260780028538760589558632766878171540458953514382464234321326889464182768467546703537516986049910576551282076245490090389328944075868508455133942304583236903222948165808559332123348274797826204144723168738177180919299881250404026184124858368.0)))

;; Exact_rounding_for_integers
  (assert
  (forall ((m mode) (i Int))
  (=> (and (<= (- 9007199254740992) i) (<= i 9007199254740992))
  (= (round1 m (to_real i)) (to_real i)))))

;; Round_down_le
  (assert (forall ((x Real)) (<= (round1 Down x) x)))

;; Round_up_ge
  (assert (forall ((x Real)) (<= x (round1 Up x))))

;; Round_down_neg
  (assert (forall ((x Real)) (= (round1 Down (- x)) (- (round1 Up x)))))

;; Round_up_neg
  (assert (forall ((x Real)) (= (round1 Up (- x)) (- (round1 Down x)))))

(declare-fun round_logic1 (mode Real) double)

;; Round_logic_def
  (assert
  (forall ((m mode) (x Real))
  (=> (no_overflow1 m x) (= (value1 (round_logic1 m x)) (round1 m x)))))

(define-fun of_real_post1 ((m mode) (x Real)
  (res double)) Bool (and (= (value1 res) (round1 m x))
                     (and (= (exact1 res) x) (= (model1 res) x))))

(define-fun add_post1 ((m mode) (x double) (y double)
  (res double)) Bool (and
                     (= (value1 res) (round1 m (+ (value1 x) (value1 y))))
                     (and (= (exact1 res) (+ (exact1 x) (exact1 y)))
                     (= (model1 res) (+ (model1 x) (model1 y))))))

(define-fun sub_post1 ((m mode) (x double) (y double)
  (res double)) Bool (and
                     (= (value1 res) (round1 m (- (value1 x) (value1 y))))
                     (and (= (exact1 res) (- (exact1 x) (exact1 y)))
                     (= (model1 res) (- (model1 x) (model1 y))))))

(define-fun mul_post1 ((m mode) (x double) (y double)
  (res double)) Bool (and
                     (= (value1 res) (round1 m (* (value1 x) (value1 y))))
                     (and (= (exact1 res) (* (exact1 x) (exact1 y)))
                     (= (model1 res) (* (model1 x) (model1 y))))))

(define-fun div_post1 ((m mode) (x double) (y double)
  (res double)) Bool (and
                     (= (value1 res) (round1 m (/ (value1 x) (value1 y))))
                     (and (= (exact1 res) (/ (exact1 x) (exact1 y)))
                     (= (model1 res) (/ (model1 x) (model1 y))))))

(define-fun neg_post1 ((x double)
  (res double)) Bool (and (= (value1 res) (- (value1 x)))
                     (and (= (exact1 res) (- (exact1 x)))
                     (= (model1 res) (- (model1 x))))))

(define-fun lt1 ((x double) (y double)) Bool (< (value1 x) (value1 y)))

(define-fun gt1 ((x double) (y double)) Bool (< (value1 y) (value1 x)))

;; round_single_bound
  (assert
  (forall ((x Real))
  (! (and
     (<= (- (- x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0)) 
     (round NearestTiesToEven x))
     (<= (round NearestTiesToEven x) (+ (+ x (* (/ 1.0 16777216.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 1427247692705959881058285969449495136382746624.0)))) :pattern (
  (round NearestTiesToEven x)) )))

;; round_double_bound
  (assert
  (forall ((x Real))
  (! (and
     (<= (- (- x (* (/ 1.0 9007199254740992.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 404804506614621236704990693437834614099113299528284236713802716054860679135990693783920767402874248990374155728633623822779617474771586953734026799881477019843034848553132722728933815484186432682479535356945490137124014966849385397236206711298319112681620113024717539104666829230461005064372655017292012526615415482186989568.0)) 
     (round1 NearestTiesToEven x))
     (<= (round1 NearestTiesToEven x) (+ (+ x (* (/ 1.0 9007199254740992.0) (ite (>= x 0.0) x (- x)))) (/ 1.0 404804506614621236704990693437834614099113299528284236713802716054860679135990693783920767402874248990374155728633623822779617474771586953734026799881477019843034848553132722728933815484186432682479535356945490137124014966849385397236206711298319112681620113024717539104666829230461005064372655017292012526615415482186989568.0)))) :pattern (
  (round1 NearestTiesToEven x)) )))

;; round_double_single
  (assert
  (forall ((x Real))
  (! (= (round1 NearestTiesToEven (round NearestTiesToEven x)) (round
                                                               NearestTiesToEven
                                                               x)) :pattern (
  (round NearestTiesToEven x)) )))

(declare-fun round2 (Real) Int)

;; Round_down
  (assert
  (forall ((x Real))
  (=> (< (- x (to_real (to_int x))) (/ 5.0 10.0)) (= (round2 x) (to_int x)))))

;; Round_up
  (assert
  (forall ((x Real))
  (=> (< (- (to_real (- 1 (to_int (- 1.0 x)))) x) (/ 5.0 10.0))
  (= (round2 x) (- 1 (to_int (- 1.0 x)))))))

;; Round_neg_tie
  (assert
  (forall ((x Real))
  (=> (and (= (- x (to_real (to_int x))) (/ 5.0 10.0)) (< x 0.0))
  (= (round2 x) (to_int x)))))

;; Round_pos_tie
  (assert
  (forall ((x Real))
  (=>
  (and (= (- (to_real (- 1 (to_int (- 1.0 x)))) x) (/ 5.0 10.0)) (< 0.0 x))
  (= (round2 x) (- 1 (to_int (- 1.0 x)))))))

;; Round_int
  (assert
  (forall ((i Int))
  (! (= (round2 (to_real i)) i) :pattern ((round2 (to_real i))) )))

;; Round_near_int
  (assert
  (forall ((i Int))
  (forall ((x Real))
  (=> (and (< (- (/ 5.0 10.0)) x) (< x (/ 5.0 10.0)))
  (= (round2 (+ (to_real i) x)) i)))))

;; Round_monotonic
  (assert
  (forall ((x Real) (y Real)) (=> (<= x y) (<= (round2 x) (round2 y)))))

;; Round_monotonic_int1
  (assert
  (forall ((x Real) (i Int)) (=> (<= x (to_real i)) (<= (round2 x) i))))

;; Round_monotonic_int2
  (assert
  (forall ((x Real) (i Int)) (=> (<= (to_real i) x) (<= i (round2 x)))))

;; Round_bound
  (assert
  (forall ((x Real))
  (and (<= (- x (/ 5.0 10.0)) (to_real (round2 x)))
  (<= (to_real (round2 x)) (+ x (/ 5.0 10.0))))))

(define-fun in_range4 ((x Real)) Bool (and (<= (- 90.0) x) (<= x 90.0)))

(declare-fun to_real1 (latitude) Real)

(declare-fun of_real (Real) latitude)

(declare-fun user_eq3 (latitude latitude) Bool)

(declare-fun next_representable (Real) Real)

(declare-fun prev_representable (Real) Real)

;; next_representable_def
  (assert
  (forall ((x Real))
  (! (< x (next_representable x)) :pattern ((next_representable x)) )))

;; prev_representable_def
  (assert
  (forall ((x Real))
  (! (< (prev_representable x) x) :pattern ((prev_representable x)) )))

(declare-fun attr__ATTRIBUTE_IMAGE4 (Real) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Real)) (sort us_image (attr__ATTRIBUTE_IMAGE4 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check4 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE4 (uni) Real)

(declare-fun dummy3 () latitude)

;; inversion_axiom
  (assert
  (forall ((x latitude))
  (! (= (of_real (to_real1 x)) x) :pattern ((to_real1 x)) )))

;; representable_first
  (assert (= (round NearestTiesToEven (- 90.0)) (- 90.0)))

;; representable_last
  (assert (= (round NearestTiesToEven 90.0) 90.0))

;; range_axiom
  (assert (forall ((x latitude)) (in_range4 (to_real1 x))))

(define-fun in_range5 ((x Real)) Bool (and (<= (- 180.0) x) (<= x 180.0)))

(declare-fun to_real2 (longitude) Real)

(declare-fun of_real1 (Real) longitude)

(declare-fun user_eq4 (longitude longitude) Bool)

(declare-fun next_representable1 (Real) Real)

(declare-fun prev_representable1 (Real) Real)

;; next_representable_def
  (assert
  (forall ((x Real))
  (! (< x (next_representable1 x)) :pattern ((next_representable1 x)) )))

;; prev_representable_def
  (assert
  (forall ((x Real))
  (! (< (prev_representable1 x) x) :pattern ((prev_representable1 x)) )))

(declare-fun attr__ATTRIBUTE_IMAGE5 (Real) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Real)) (sort us_image (attr__ATTRIBUTE_IMAGE5 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check5 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE5 (uni) Real)

(declare-fun dummy4 () longitude)

;; inversion_axiom
  (assert
  (forall ((x longitude))
  (! (= (of_real1 (to_real2 x)) x) :pattern ((to_real2 x)) )))

;; representable_first
  (assert (= (round NearestTiesToEven (- 180.0)) (- 180.0)))

;; representable_last
  (assert (= (round NearestTiesToEven 180.0) 180.0))

;; range_axiom
  (assert (forall ((x longitude)) (in_range5 (to_real2 x))))

(declare-fun mk___split_fields (latitude longitude) us_split_fields)

(declare-fun rec__lat (us_split_fields) latitude)

;; rec__lat_def
  (assert
  (forall ((u latitude) (u1 longitude))
  (= (rec__lat (mk___split_fields u u1)) u)))

(declare-fun rec__long (us_split_fields) longitude)

;; rec__long_def
  (assert
  (forall ((u latitude) (u1 longitude))
  (= (rec__long (mk___split_fields u u1)) u1)))

(declare-fun mk_gpslocation (us_split_fields) gpslocation)

(declare-fun us_split_fields2 (gpslocation) us_split_fields)

;; __split_fields_def
  (assert
  (forall ((u us_split_fields)) (= (us_split_fields2 (mk_gpslocation u)) u)))

(define-fun bool_eq4 ((a gpslocation)
  (b gpslocation)) Bool (ite (and
                             (= (to_real1 (rec__lat (us_split_fields2 a))) 
                             (to_real1 (rec__lat (us_split_fields2 b))))
                             (= (to_real2 (rec__long (us_split_fields2 a))) 
                             (to_real2 (rec__long (us_split_fields2 b)))))
                        true false))

(declare-fun user_eq5 (gpslocation gpslocation) Bool)

(declare-fun value__size () Int)

(declare-fun object__size (gpslocation) Int)

;; value__size_axiom
  (assert (<= 0 value__size))

;; object__size_axiom
  (assert (forall ((a gpslocation)) (<= 0 (object__size a))))

(declare-fun dummy5 () gpslocation)

(declare-fun dummy6 () (map1 Bool))

(declare-fun value__size1 () Int)

(declare-fun object__size1 ((map1 Bool)) Int)

;; value__size_axiom
  (assert (<= 0 value__size1))

;; object__size_axiom
  (assert (forall ((a (map1 Bool))) (<= 0 (object__size1 a))))

(declare-fun user_eq6 ((map1 Bool) (map1 Bool)) Bool)

(declare-fun t2tb8 ((map1 Bool)) uni)

;; t2tb_sort
  (assert (forall ((x (map1 Bool))) (sort (map2 bool) (t2tb8 x))))

(declare-fun tb2t8 (uni) (map1 Bool))

;; BridgeL
  (assert
  (forall ((i (map1 Bool)))
  (! (= (tb2t8 (t2tb8 i)) i) :pattern ((t2tb8 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (map2 bool) j) (= (t2tb8 (tb2t8 j)) j)) :pattern ((t2tb8
                                                                 (tb2t8 j))) )))

(declare-fun t2tb9 (Bool) uni)

;; t2tb_sort
  (assert (forall ((x Bool)) (sort bool (t2tb9 x))))

(declare-fun tb2t9 (uni) Bool)

;; BridgeL
  (assert
  (forall ((i Bool)) (! (= (tb2t9 (t2tb9 i)) i) :pattern ((t2tb9 i)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort bool j) (= (t2tb9 (tb2t9 j)) j)) :pattern ((t2tb9 (tb2t9 j))) )))

;; compare_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (and
     (=
     (= (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) 0)
     (= (bool_eq bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) true))
     (and
     (=
     (< (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and (= (bool_eq bool (t2tb8 a) a_first i (t2tb8 b) b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_int1 (tb2t9 (get bool (t2tb8 a) (+ i 1)))) (to_int1
                                                       (tb2t9
                                                       (get bool (t2tb8 b)
                                                       (+ j 1))))))))))))
     (=
     (< 0 (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and (= (bool_eq bool (t2tb8 a) a_first j (t2tb8 b) b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_int1 (tb2t9 (get bool (t2tb8 b) (+ i 1)))) (to_int1
                                                       (tb2t9
                                                       (get bool (t2tb8 a)
                                                       (+ j 1)))))))))))))) :pattern (
  (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last)) ))))

;; op_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9
        (get bool
        (orb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i)) (or 
     (tb2t9 (get bool (t2tb8 a) i)) (tb2t9
                                    (get bool (t2tb8 b)
                                    (+ (- i a_first) b_first)))))) :pattern (
  (tb2t9
  (get bool (orb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i))) )))))

;; op_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9
        (get bool
        (andb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i)) (and 
     (tb2t9 (get bool (t2tb8 a) i)) (tb2t9
                                    (get bool (t2tb8 b)
                                    (+ (- i a_first) b_first)))))) :pattern (
  (tb2t9
  (get bool (andb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i))) )))))

;; op_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9
        (get bool
        (xorb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i)) (xor 
     (tb2t9 (get bool (t2tb8 a) i)) (tb2t9
                                    (get bool (t2tb8 b)
                                    (+ (- i a_first) b_first)))))) :pattern (
  (tb2t9
  (get bool (xorb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i))) )))))

;; notb_def
  (assert
  (forall ((a (map1 Bool)))
  (forall ((a_first Int) (a_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9 (get bool (notb bool (t2tb8 a) a_first a_last) i)) (not 
     (tb2t9 (get bool (t2tb8 a) i))))) :pattern ((tb2t9
                                                 (get bool
                                                 (notb bool (t2tb8 a) a_first
                                                 a_last) i))) )))))

(declare-fun dummy7 () (map1 userid))

(declare-fun value__size2 () Int)

(declare-fun object__size2 ((map1 userid)) Int)

;; value__size_axiom
  (assert (<= 0 value__size2))

;; object__size_axiom
  (assert (forall ((a (map1 userid))) (<= 0 (object__size2 a))))

(declare-fun user_eq7 ((map1 userid) (map1 userid)) Bool)

;; compare_def
  (assert
  (forall ((a (map1 userid)) (b (map1 userid)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (and
     (=
     (= (compare userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last) 0)
     (= (bool_eq userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last) true))
     (and
     (=
     (< (compare userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and (= (bool_eq userid1 (t2tb6 a) a_first i (t2tb6 b) b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_rep (get1 a (+ i 1))) (to_rep (get1 b (+ j 1)))))))))))
     (=
     (< 0 (compare userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and (= (bool_eq userid1 (t2tb6 a) a_first j (t2tb6 b) b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_rep (get1 b (+ i 1))) (to_rep (get1 a (+ j 1))))))))))))) :pattern (
  (compare userid1 (t2tb6 a) a_first a_last (t2tb6 b) b_first b_last)) ))))

(declare-fun dummy8 () (map1 bpm))

(declare-fun value__size3 () Int)

(declare-fun object__size3 ((map1 bpm)) Int)

;; value__size_axiom
  (assert (<= 0 value__size3))

;; object__size_axiom
  (assert (forall ((a (map1 bpm))) (<= 0 (object__size3 a))))

(declare-fun user_eq8 ((map1 bpm) (map1 bpm)) Bool)

;; compare_def
  (assert
  (forall ((a (map1 bpm)) (b (map1 bpm)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (and
     (=
     (= (compare bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last) 0)
     (= (bool_eq bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last) true))
     (and
     (=
     (< (compare bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and (= (bool_eq bpm1 (t2tb4 a) a_first i (t2tb4 b) b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_rep1 (get2 a (+ i 1))) (to_rep1 (get2 b (+ j 1)))))))))))
     (=
     (< 0 (compare bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and (= (bool_eq bpm1 (t2tb4 a) a_first j (t2tb4 b) b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_rep1 (get2 b (+ i 1))) (to_rep1 (get2 a (+ j 1))))))))))))) :pattern (
  (compare bpm1 (t2tb4 a) a_first a_last (t2tb4 b) b_first b_last)) ))))

(declare-fun dummy9 () (map1 footsteps))

(declare-fun value__size4 () Int)

(declare-fun object__size4 ((map1 footsteps)) Int)

;; value__size_axiom
  (assert (<= 0 value__size4))

;; object__size_axiom
  (assert (forall ((a (map1 footsteps))) (<= 0 (object__size4 a))))

(declare-fun user_eq9 ((map1 footsteps) (map1 footsteps)) Bool)

;; compare_def
  (assert
  (forall ((a (map1 footsteps)) (b (map1 footsteps)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (and
     (=
     (= (compare footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first
        b_last) 0)
     (= (bool_eq footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first
        b_last) true))
     (and
     (=
     (< (compare footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first
        b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and
     (= (bool_eq footsteps1 (t2tb3 a) a_first i (t2tb3 b) b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_rep2 (get3 a (+ i 1))) (to_rep2 (get3 b (+ j 1)))))))))))
     (=
     (< 0 (compare footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first
          b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and
     (= (bool_eq footsteps1 (t2tb3 a) a_first j (t2tb3 b) b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_rep2 (get3 b (+ i 1))) (to_rep2 (get3 a (+ j 1))))))))))))) :pattern (
  (compare footsteps1 (t2tb3 a) a_first a_last (t2tb3 b) b_first b_last)) ))))

(declare-fun dummy10 () (map1 gpslocation))

(declare-fun value__size5 () Int)

(declare-fun object__size5 ((map1 gpslocation)) Int)

;; value__size_axiom
  (assert (<= 0 value__size5))

;; object__size_axiom
  (assert (forall ((a (map1 gpslocation))) (<= 0 (object__size5 a))))

(declare-fun user_eq10 ((map1 gpslocation) (map1 gpslocation)) Bool)

(declare-fun attr__ATTRIBUTE_ADDRESS () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS1 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS2 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS3 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS4 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS5 () Int)

(declare-sort t1b 0)

(declare-fun t1b1 () ty)

(define-fun in_range6 ((x Int)) Bool (and (<= (- 1) x) (<= x 100)))

(define-fun bool_eq5 ((x Int) (y Int)) Bool (ite (= x y) true false))

(declare-fun attr__ATTRIBUTE_IMAGE6 (Int) uni)

;; attr__ATTRIBUTE_IMAGE_sort
  (assert (forall ((x Int)) (sort us_image (attr__ATTRIBUTE_IMAGE6 x))))

(declare-fun attr__ATTRIBUTE_VALUE__pre_check6 (uni) Bool)

(declare-fun attr__ATTRIBUTE_VALUE6 (uni) Int)

(declare-fun to_rep3 (t1b) Int)

(declare-fun of_rep3 (Int) t1b)

(declare-fun user_eq11 (t1b t1b) Bool)

(declare-fun dummy11 () t1b)

;; inversion_axiom
  (assert
  (forall ((x t1b)) (! (= (of_rep3 (to_rep3 x)) x) :pattern ((to_rep3 x)) )))

;; range_axiom
  (assert (forall ((x t1b)) (in_range6 (to_rep3 x))))

;; coerce_axiom
  (assert
  (forall ((x Int))
  (! (=> (in_range6 x) (= (to_rep3 (of_rep3 x)) x)) :pattern ((to_rep3
                                                              (of_rep3 x))) )))

(declare-fun dummy12 () (map1 Bool))

(declare-fun value__size6 () Int)

(declare-fun object__size6 ((map1 Bool)) Int)

;; value__size_axiom
  (assert (<= 0 value__size6))

;; object__size_axiom
  (assert (forall ((a (map1 Bool))) (<= 0 (object__size6 a))))

(declare-fun user_eq12 ((map1 Bool) (map1 Bool)) Bool)

;; compare_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (! (and
     (=
     (= (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) 0)
     (= (bool_eq bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) true))
     (and
     (=
     (< (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) 0)
     (exists ((i Int) (j Int))
     (and (<= i a_last)
     (and (< j b_last)
     (and (= (bool_eq bool (t2tb8 a) a_first i (t2tb8 b) b_first j) true)
     (or (= i a_last)
     (and (< i a_last)
     (< (to_int1 (tb2t9 (get bool (t2tb8 a) (+ i 1)))) (to_int1
                                                       (tb2t9
                                                       (get bool (t2tb8 b)
                                                       (+ j 1))))))))))))
     (=
     (< 0 (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last))
     (exists ((i Int) (j Int))
     (and (<= i b_last)
     (and (< j a_last)
     (and (= (bool_eq bool (t2tb8 a) a_first j (t2tb8 b) b_first i) true)
     (or (= i b_last)
     (and (< i b_last)
     (< (to_int1 (tb2t9 (get bool (t2tb8 b) (+ i 1)))) (to_int1
                                                       (tb2t9
                                                       (get bool (t2tb8 a)
                                                       (+ j 1)))))))))))))) :pattern (
  (compare bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last)) ))))

;; op_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9
        (get bool
        (orb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i)) (or 
     (tb2t9 (get bool (t2tb8 a) i)) (tb2t9
                                    (get bool (t2tb8 b)
                                    (+ (- i a_first) b_first)))))) :pattern (
  (tb2t9
  (get bool (orb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i))) )))))

;; op_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9
        (get bool
        (andb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i)) (and 
     (tb2t9 (get bool (t2tb8 a) i)) (tb2t9
                                    (get bool (t2tb8 b)
                                    (+ (- i a_first) b_first)))))) :pattern (
  (tb2t9
  (get bool (andb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i))) )))))

;; op_def
  (assert
  (forall ((a (map1 Bool)) (b (map1 Bool)))
  (forall ((a_first Int) (a_last Int) (b_first Int) (b_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9
        (get bool
        (xorb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i)) (xor 
     (tb2t9 (get bool (t2tb8 a) i)) (tb2t9
                                    (get bool (t2tb8 b)
                                    (+ (- i a_first) b_first)))))) :pattern (
  (tb2t9
  (get bool (xorb bool (t2tb8 a) a_first a_last (t2tb8 b) b_first b_last) i))) )))))

;; notb_def
  (assert
  (forall ((a (map1 Bool)))
  (forall ((a_first Int) (a_last Int))
  (forall ((i Int))
  (! (=> (and (<= a_first i) (<= i a_last))
     (= (tb2t9 (get bool (notb bool (t2tb8 a) a_first a_last) i)) (not 
     (tb2t9 (get bool (t2tb8 a) i))))) :pattern ((tb2t9
                                                 (get bool
                                                 (notb bool (t2tb8 a) a_first
                                                 a_last) i))) )))))

(declare-fun attr__ATTRIBUTE_ADDRESS6 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS7 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS8 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS9 () Int)

(declare-fun attr__ATTRIBUTE_ADDRESS10 () Int)

(declare-fun temp___standard__accountmanagementsystem_62 (Bool) (map1 Bool))

;; def_axiom
  (assert
  (forall ((temp___standard__accountmanagementsystem_64 Bool))
  (! (forall ((temp___standard__accountmanagementsystem_65 Int))
     (= (tb2t9
        (get bool
        (t2tb8
        (temp___standard__accountmanagementsystem_62
        temp___standard__accountmanagementsystem_64))
        temp___standard__accountmanagementsystem_65)) temp___standard__accountmanagementsystem_64)) :pattern (
  (temp___standard__accountmanagementsystem_62
  temp___standard__accountmanagementsystem_64)) )))

(declare-fun insurers () (map1 userid))

(declare-fun friends () (map1 userid))

(declare-fun vitals () (map1 bpm))

(declare-fun mfootsteps () (map1 footsteps))

(declare-fun locations () (map1 gpslocation))

(declare-fun o () (map1 Bool))

(declare-fun o1 () userid)

(declare-fun o2 () (map1 userid))

(declare-fun o3 () userid)

(declare-fun o4 () (map1 userid))

(declare-fun o5 () bpm)

(declare-fun o6 () (map1 bpm))

(declare-fun o7 () footsteps)

(declare-fun o8 () (map1 footsteps))

(declare-fun o9 () longitude)

(declare-fun o10 () latitude)

(declare-fun o11 () latitude)

(declare-fun o12 () longitude)

(declare-fun o13 () latitude)

(declare-fun o14 () longitude)

(declare-fun o15 () (map1 gpslocation))

(declare-fun insurers1 () (map1 userid))

(declare-fun friends1 () (map1 userid))

(declare-fun vitals1 () (map1 bpm))

(declare-fun mfootsteps1 () (map1 footsteps))

(declare-fun locations1 () (map1 gpslocation))

(declare-fun users () (map1 Bool))

(declare-fun i () Int)

(declare-fun friends2 () (map1 userid))

(declare-fun i1 () Int)

(declare-fun friends3 () (map1 userid))

(declare-fun i2 () Int)

(declare-fun friends4 () (map1 userid))

(declare-fun i3 () Int)

(declare-fun friends5 () (map1 userid))

(declare-fun i4 () Int)

(declare-fun i5 () Int)

(declare-fun insurers2 () (map1 userid))

(declare-fun i6 () Int)

(declare-fun insurers3 () (map1 userid))

(declare-fun i7 () Int)

(declare-fun insurers4 () (map1 userid))

(declare-fun i8 () Int)

(declare-fun insurers5 () (map1 userid))

(declare-fun i9 () Int)

(declare-fun i10 () Int)

(declare-fun vitals2 () (map1 bpm))

(declare-fun i11 () Int)

(declare-fun vitals3 () (map1 bpm))

(declare-fun i12 () Int)

(declare-fun vitals4 () (map1 bpm))

(declare-fun i13 () Int)

(declare-fun vitals5 () (map1 bpm))

(declare-fun i14 () Int)

(declare-fun i15 () Int)

(declare-fun mfootsteps2 () (map1 footsteps))

(declare-fun i16 () Int)

(declare-fun mfootsteps3 () (map1 footsteps))

(declare-fun i17 () Int)

(declare-fun mfootsteps4 () (map1 footsteps))

(declare-fun i18 () Int)

(declare-fun mfootsteps5 () (map1 footsteps))

(declare-fun i19 () Int)

(declare-fun i20 () Int)

(declare-fun locations2 () (map1 gpslocation))

(declare-fun i21 () Int)

(declare-fun locations3 () (map1 gpslocation))

(declare-fun i22 () Int)

(declare-fun locations4 () (map1 gpslocation))

(declare-fun i23 () Int)

(declare-fun locations5 () (map1 gpslocation))

(declare-fun i24 () Int)

(declare-fun users1 () (map1 Bool))

(declare-fun insurers6 () (map1 userid))

(declare-fun friends6 () (map1 userid))

(declare-fun vitals6 () (map1 bpm))

(declare-fun mfootsteps6 () (map1 footsteps))

(declare-fun locations6 () (map1 gpslocation))

(declare-fun i25 () Int)

(declare-fun i26 () Int)

(declare-fun i27 () Int)

(declare-fun i28 () Int)

(declare-fun i29 () Int)

(declare-fun users2 () (map1 Bool))

(declare-fun insurers7 () (map1 userid))

(declare-fun friends7 () (map1 userid))

(declare-fun vitals7 () (map1 bpm))

(declare-fun mfootsteps7 () (map1 footsteps))

(declare-fun locations7 () (map1 gpslocation))

(declare-fun i30 () Int)

(declare-fun i31 () Int)

(declare-fun i32 () Int)

(declare-fun i33 () Int)

(declare-fun i34 () Int)

(declare-fun t2tb10 ((ref (map1 gpslocation))) uni)

;; t2tb_sort
  (assert
  (forall ((x (ref (map1 gpslocation)))) (sort (ref1 (map2 gpslocation1))
  (t2tb10 x))))

(declare-fun tb2t10 (uni) (ref (map1 gpslocation)))

;; BridgeL
  (assert
  (forall ((i35 (ref (map1 gpslocation))))
  (! (= (tb2t10 (t2tb10 i35)) i35) :pattern ((t2tb10 i35)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (ref1 (map2 gpslocation1)) j) (= (t2tb10 (tb2t10 j)) j)) :pattern (
  (t2tb10 (tb2t10 j))) )))

(define-fun locations8 () (ref (map1 gpslocation)) (tb2t10
                                                   (mk_ref
                                                   (map2 gpslocation1)
                                                   (t2tb locations4))))

(declare-fun t2tb11 ((ref (map1 footsteps))) uni)

;; t2tb_sort
  (assert
  (forall ((x (ref (map1 footsteps)))) (sort (ref1 (map2 footsteps1))
  (t2tb11 x))))

(declare-fun tb2t11 (uni) (ref (map1 footsteps)))

;; BridgeL
  (assert
  (forall ((i35 (ref (map1 footsteps))))
  (! (= (tb2t11 (t2tb11 i35)) i35) :pattern ((t2tb11 i35)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (ref1 (map2 footsteps1)) j) (= (t2tb11 (tb2t11 j)) j)) :pattern (
  (t2tb11 (tb2t11 j))) )))

(define-fun mfootsteps8 () (ref (map1 footsteps)) (tb2t11
                                                  (mk_ref (map2 footsteps1)
                                                  (t2tb3 mfootsteps4))))

(declare-fun t2tb12 ((ref (map1 bpm))) uni)

;; t2tb_sort
  (assert
  (forall ((x (ref (map1 bpm)))) (sort (ref1 (map2 bpm1)) (t2tb12 x))))

(declare-fun tb2t12 (uni) (ref (map1 bpm)))

;; BridgeL
  (assert
  (forall ((i35 (ref (map1 bpm))))
  (! (= (tb2t12 (t2tb12 i35)) i35) :pattern ((t2tb12 i35)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (ref1 (map2 bpm1)) j) (= (t2tb12 (tb2t12 j)) j)) :pattern (
  (t2tb12 (tb2t12 j))) )))

(define-fun vitals8 () (ref (map1 bpm)) (tb2t12
                                        (mk_ref (map2 bpm1) (t2tb4 vitals4))))

(declare-fun t2tb13 ((ref (map1 userid))) uni)

;; t2tb_sort
  (assert
  (forall ((x (ref (map1 userid)))) (sort (ref1 (map2 userid1)) (t2tb13 x))))

(declare-fun tb2t13 (uni) (ref (map1 userid)))

;; BridgeL
  (assert
  (forall ((i35 (ref (map1 userid))))
  (! (= (tb2t13 (t2tb13 i35)) i35) :pattern ((t2tb13 i35)) )))

;; BridgeR
  (assert
  (forall ((j uni))
  (! (=> (sort (ref1 (map2 userid1)) j) (= (t2tb13 (tb2t13 j)) j)) :pattern (
  (t2tb13 (tb2t13 j))) )))

(define-fun insurers8 () (ref (map1 userid)) (tb2t13
                                             (mk_ref (map2 userid1)
                                             (t2tb6 insurers4))))

(define-fun friends8 () (ref (map1 userid)) (tb2t13
                                            (mk_ref (map2 userid1)
                                            (t2tb6 friends4))))

;; H
  (assert true)

;; H
  (assert (= o (temp___standard__accountmanagementsystem_62 (of_int 0))))

;; H
  (assert (= users o))

;; H
  (assert (= i (- 1)))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (and (<= (- 1) i1) (<= i1 100))))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= (to_rep o1) (- 1))))

;; H
  (assert
  (=> (and (<= (- 1) i) (<= i 100))
  (= o2 (tb2t6 (set userid1 (t2tb6 friends2) i1 (t2tb7 o1))))))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= friends3 o2)))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= i2 (+ i1 1))))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (not (<= i2 100))))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= i2 i3)))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= friends3 friends4)))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= i4 i2)))

;; H
  (assert (=> (and (<= (- 1) i) (<= i 100)) (= friends5 friends3)))

;; H
  (assert (=> (not (and (<= (- 1) i) (<= i 100))) (= i i3)))

;; H
  (assert
  (=> (not (and (<= (- 1) i) (<= i 100)))
  (= friends8 (tb2t13 (mk_ref (map2 userid1) (t2tb6 friends))))))

;; H
  (assert (=> (not (and (<= (- 1) i) (<= i 100))) (= i4 i)))

;; H
  (assert (=> (not (and (<= (- 1) i) (<= i 100))) (= friends5 friends1)))

;; H
  (assert (= i5 (- 1)))

;; H
  (assert
  (=> (and (<= (- 1) i5) (<= i5 100)) (and (<= (- 1) i6) (<= i6 100))))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= (to_rep o3) (- 1))))

;; H
  (assert
  (=> (and (<= (- 1) i5) (<= i5 100))
  (= o4 (tb2t6 (set userid1 (t2tb6 insurers2) i6 (t2tb7 o3))))))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= insurers3 o4)))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= i7 (+ i6 1))))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (not (<= i7 100))))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= i7 i8)))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= insurers3 insurers4)))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= i9 i7)))

;; H
  (assert (=> (and (<= (- 1) i5) (<= i5 100)) (= insurers5 insurers3)))

;; H
  (assert (=> (not (and (<= (- 1) i5) (<= i5 100))) (= i5 i8)))

;; H
  (assert
  (=> (not (and (<= (- 1) i5) (<= i5 100)))
  (= insurers8 (tb2t13 (mk_ref (map2 userid1) (t2tb6 insurers))))))

;; H
  (assert (=> (not (and (<= (- 1) i5) (<= i5 100))) (= i9 i5)))

;; H
  (assert (=> (not (and (<= (- 1) i5) (<= i5 100))) (= insurers5 insurers1)))

;; H
  (assert (= i10 (- 1)))

;; H
  (assert
  (=> (and (<= (- 1) i10) (<= i10 100)) (and (<= (- 1) i11) (<= i11 100))))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= (to_rep1 o5) (- 1))))

;; H
  (assert
  (=> (and (<= (- 1) i10) (<= i10 100))
  (= o6 (tb2t4 (set bpm1 (t2tb4 vitals2) i11 (t2tb5 o5))))))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= vitals3 o6)))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= i12 (+ i11 1))))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (not (<= i12 100))))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= i12 i13)))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= vitals3 vitals4)))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= i14 i12)))

;; H
  (assert (=> (and (<= (- 1) i10) (<= i10 100)) (= vitals5 vitals3)))

;; H
  (assert (=> (not (and (<= (- 1) i10) (<= i10 100))) (= i10 i13)))

;; H
  (assert
  (=> (not (and (<= (- 1) i10) (<= i10 100)))
  (= vitals8 (tb2t12 (mk_ref (map2 bpm1) (t2tb4 vitals))))))

;; H
  (assert (=> (not (and (<= (- 1) i10) (<= i10 100))) (= i14 i10)))

;; H
  (assert (=> (not (and (<= (- 1) i10) (<= i10 100))) (= vitals5 vitals1)))

;; H
  (assert (= i15 (- 1)))

;; H
  (assert
  (=> (and (<= (- 1) i15) (<= i15 100)) (and (<= (- 1) i16) (<= i16 100))))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= (to_rep2 o7) 0)))

;; H
  (assert
  (=> (and (<= (- 1) i15) (<= i15 100))
  (= o8 (tb2t3 (set footsteps1 (t2tb3 mfootsteps2) i16 (t2tb2 o7))))))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= mfootsteps3 o8)))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= i17 (+ i16 1))))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (not (<= i17 100))))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= i17 i18)))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= mfootsteps3 mfootsteps4)))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= i19 i17)))

;; H
  (assert (=> (and (<= (- 1) i15) (<= i15 100)) (= mfootsteps5 mfootsteps3)))

;; H
  (assert (=> (not (and (<= (- 1) i15) (<= i15 100))) (= i15 i18)))

;; H
  (assert
  (=> (not (and (<= (- 1) i15) (<= i15 100)))
  (= mfootsteps8 (tb2t11 (mk_ref (map2 footsteps1) (t2tb3 mfootsteps))))))

;; H
  (assert (=> (not (and (<= (- 1) i15) (<= i15 100))) (= i19 i15)))

;; H
  (assert
  (=> (not (and (<= (- 1) i15) (<= i15 100))) (= mfootsteps5 mfootsteps1)))

;; H
  (assert (= i20 (- 1)))

;; H
  (assert
  (=> (and (<= (- 1) i20) (<= i20 100)) (and (<= (- 1) i21) (<= i21 100))))

;; H
  (assert
  (=> (and (<= (- 1) i20) (<= i20 100)) (= (to_real2 o9) (/ 0.0 10.0))))

;; H
  (assert
  (=> (and (<= (- 1) i20) (<= i20 100)) (= (to_real1 o10) (/ 0.0 10.0))))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= o10 o11)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= o9 o12)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= o13 o11)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= o14 o12)))

;; H
  (assert
  (=> (and (<= (- 1) i20) (<= i20 100))
  (= o15 (tb2t
         (set gpslocation1 (t2tb locations2) i21
         (t2tb1 (mk_gpslocation (mk___split_fields o13 o14))))))))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= locations3 o15)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= i22 (+ i21 1))))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (not (<= i22 100))))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= i22 i23)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= locations3 locations4)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= i24 i22)))

;; H
  (assert (=> (and (<= (- 1) i20) (<= i20 100)) (= locations5 locations3)))

;; H
  (assert (=> (not (and (<= (- 1) i20) (<= i20 100))) (= i20 i23)))

;; H
  (assert
  (=> (not (and (<= (- 1) i20) (<= i20 100)))
  (= locations8 (tb2t10 (mk_ref (map2 gpslocation1) (t2tb locations))))))

;; H
  (assert (=> (not (and (<= (- 1) i20) (<= i20 100))) (= i24 i20)))

;; H
  (assert
  (=> (not (and (<= (- 1) i20) (<= i20 100))) (= locations5 locations1)))

;; H
  (assert (= i29 i23))

;; H
  (assert (= i28 i18))

;; H
  (assert (= i27 i13))

;; H
  (assert (= i26 i8))

;; H
  (assert (= i25 i3))

;; H
  (assert
  (= (tb2t10 (mk_ref (map2 gpslocation1) (t2tb locations6))) locations8))

;; H
  (assert
  (= (tb2t11 (mk_ref (map2 footsteps1) (t2tb3 mfootsteps6))) mfootsteps8))

;; H
  (assert (= (tb2t12 (mk_ref (map2 bpm1) (t2tb4 vitals6))) vitals8))

;; H
  (assert (= (tb2t13 (mk_ref (map2 userid1) (t2tb6 friends6))) friends8))

;; H
  (assert (= (tb2t13 (mk_ref (map2 userid1) (t2tb6 insurers6))) insurers8))

;; H
  (assert (= users1 users))

;; H
  (assert (= i34 i24))

;; H
  (assert (= i33 i19))

;; H
  (assert (= i32 i14))

;; H
  (assert (= i31 i9))

;; H
  (assert (= i30 i4))

;; H
  (assert (= locations7 locations5))

;; H
  (assert (= mfootsteps7 mfootsteps5))

;; H
  (assert (= vitals7 vitals5))

;; H
  (assert (= friends7 friends5))

;; H
  (assert (= insurers7 insurers5))

;; H
  (assert (= users2 users))

(assert
;; WP_parameter_def
 ;; File "/Users/raywong/Documents/workspace/Ada/Assignment4/gnatprove/accountmanagementsystem/../accountmanagementsystem.mlw", line 16889, characters 5-8
  (not
  (and
  (and
  (and
  (and
  (forall ((i35 Int))
  (=> (and (<= (- 1) i35) (<= i35 100))
  (= (to_rep (get1 friends6 i35)) (- 1))))
  (forall ((i35 Int))
  (=> (and (<= (- 1) i35) (<= i35 100))
  (= (to_rep (get1 insurers6 i35)) (- 1)))))
  (forall ((i35 Int))
  (=> (and (<= (- 1) i35) (<= i35 100))
  (= (to_rep1 (get2 vitals6 i35)) (- 1)))))
  (forall ((i35 Int))
  (=> (and (<= (- 1) i35) (<= i35 100))
  (= (to_rep2 (get3 mfootsteps6 i35)) 0))))
  (forall ((i35 Int))
  (=> (and (<= (- 1) i35) (<= i35 100))
  (= (bool_eq4 (get4 locations6 i35)
     (mk_gpslocation
     (mk___split_fields (of_real (/ 0.0 10.0)) (of_real1 (/ 0.0 10.0))))) true))))))
(check-sat)
